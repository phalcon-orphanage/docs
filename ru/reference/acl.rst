Списки Контроля Доступа (ACL)
=============================
:doc:`Phalcon\\Acl <../api/Phalcon_Acl>` предоставляет простое и легкое управление контролем доступа и прикрепленными
разрешениями. `Список контроля доступа`_ (ACL) позволяет приложению управлять доступом к своим областям и основным
запрошенным объектам.
Необходимо понимать основные методологии ACL, чтобы понимать принцип работы.

И в заключении: ACL состоит из ролей и ресурсов. Ресурсами являются объекты, на которые накладываются определенные
разрешения с помощью ACL. Ролями являются объекты, которые запрашивают доступ к ресурсам и получаются ответ от ACL: разрешено/запрещенно.

Создание ACL
------------
Этот компонент изначально сделан так, чтобы работать непосредственно в памяти. Это предоставляет простое использование
и скорость в обращении к любому аспекту списка. Конструктор :doc:`Phalcon\\Acl <../api/Phalcon_Acl>` принимает в качестве
первого параметра адаптер, который будет использоваться для получения информации связанной с контролируемым списком.
Пример использования адаптера памяти:

.. code-block:: php

    <?php $acl = new \Phalcon\Acl\Adapter\Memory();

По умолчанию :doc:`Phalcon\\Acl <../api/Phalcon_Acl>` предоставляет доступ к действию над ресурсом, которое еще не было
определенно в ACL. Чтобы увеличить уровень безопасности мы можем указать уровень "запрещенно", как уровень по умолчанию.

.. code-block:: php

    <?php

    // Указываем "запрещенно" по умолчанию для тех объектов, которые не были занесены в список контроля доступа
    $acl->setDefaultAction(Phalcon\Acl::DENY);

Добавление ролей
----------------
Ролью является объект, который имеет или не имеет доступа к определенному ресурсу в списке доступа. Для примера,
мы определим роли людей из организации. Класс :doc:`Phalcon\\Acl\\Role <../api/Phalcon_Acl_Role>`  позволяет создать
роли в более структурированной форме. Давайте добавим несколько ролей в наш недавно созданный список:

.. code-block:: php

    <?php

    // Создаем роли
    $roleAdmins = new \Phalcon\Acl\Role("Administrators", "Super-User role");
    $roleGuests = new \Phalcon\Acl\Role("Guests");

    // Добавляем "Guests" в список ACL
    $acl->addRole($roleGuests);

    // Добавляем "Designers" без класса Phalcon\Acl\Role
    $acl->addRole("Designers");

Как вы можете видеть, роли определяются непосредственно, без использования экземпляра.

Добавление ресурсов
-------------------
Ресурсами являются объекты, доступ к которым контролируется. Обычно в MVC приложениях ресурсы относятся к контроллерам.
Хотя это не является обязательным, класс :doc:`Phalcon\\Acl\\Resource <../api/Phalcon_Acl_Resource>` может быть использован
при определении любых ресурсов. Важно добавить связующие действия или операции над ресурсами, чтобы ACL мог понимать что ему
нужно контролировать.

.. code-block:: php

    <?php

    // Определяем ресурс "Customers"
    $customersResource = new \Phalcon\Acl\Resource("Customers");

    // Добавим ресурс "Customers" с несколькими операциями
    $acl->addResource($customersResource, "search");
    $acl->addResource($customersResource, array("create", "update"));

Определение контроля доступа
----------------------------
Теперь у нас есть роли и ресурсы. Настало время указать для ACL какие разрешения имеют роли при доступе к ресурсам.
Данная часть очень важна, особенно принимая во внимание используемый по умолчанию уровень "разрешить" или "запретить".

.. code-block:: php

    <?php

    // Задаем уровень доступа для ролей на определенный ресурс
    $acl->allow("Guests", "Customers", "search");
    $acl->allow("Guests", "Customers", "create");
    $acl->deny("Guests", "Customers", "update");

Метод "allow" определяет, что данная роль имеет доступ к действию над ресурсом. Метод "deny" делает обратное.

Запросы к ACL
-------------
После того, как список был полностью составлен мы можем запрашивать проверку на права той или иной роли.

.. code-block:: php

    <?php

    // Проверяем, имеет ли роль "Guests" доступ к разным операциям по отношению к ресурсу "Customers"
    $acl->isAllowed("Guests", "Customers", "edit");   // Возвращает 0
    $acl->isAllowed("Guests", "Customers", "search"); // Возвращает 1
    $acl->isAllowed("Guests", "Customers", "create"); // Возвращает 1

Наследование ролей
------------------
Вы можете строить сложные структуры ролей используя наследование, которое предоставляет класс
:doc:`Phalcon\\Acl\\Role <../api/Phalcon_Acl_Role>`. Роли могут наследовать доступ других ролей. Чтобы использовать
наследование ролей вам необходимо передать в качестве второго параметра другую роль при определении роли.

.. code-block:: php

    <?php

    // Создаем несколько ролей
    $roleAdmins = new \Phalcon\Acl\Role("Administrators", "Super-User role");
    $roleGuests = new \Phalcon\Acl\Role("Guests");

    // Добавляем роль "Guests"
    $acl->addRole($roleGuests);

    // Добавляем роль "Administrators" наследуемую от роли "Guests"
    $acl->addRole($roleAdmins, $roleGuests);

Сериализация ACL
----------------
Чтобы увеличить производительность, объект :doc:`Phalcon\\Acl <../api/Phalcon_Acl>` можно сериализовать для хранения
в текстовом формате или в базе данных, и повторно использовать :doc:`Phalcon\\Acl <../api/Phalcon_Acl>` без
переобъявления всего списка каждый раз. Вы можете сделать это следующим образом:

.. code-block:: php

    <?php

    // Проверяем существует ли сериализованный файл
    if (!file_exists("app/security/acl.data")) {

        $acl = new \Phalcon\Acl\Adapter\Memory();

        //... Определяем роли, ресурсы, доступ и т.д.

        // Сохраняем сериализованный объект в файл
        file_put_contents("app/security/acl.data", serialize($acl));

    } else {

         // Восстанавливаем ACL объект из текстового файла
         $acl = unserialize(file_get_contents("app/security/acl.data"));
    }

    // Используем ACL
    if ($acl->isAllowed("Guests", "Customers", "edit")) {
        echo "Доступ разрешен!";
    } else {
        echo "Доступ запрещен :(";
    }

События Acl
-----------
:doc:`Phalcon\\Acl <../api/Phalcon_Acl>` может отправлять события в :doc:`EventsManager <events>`. События срабатывают
используя тип "acl". Некоторые события могут возвращать boolean значение 'false', чтобы прервать текущую операцию.
Поддерживаются следующие типы событий:

+----------------------+------------------------------------------------------------+----------------------------+
| Название события     | Когда срабатывает                                          | Может остановить операцию? |
+======================+============================================================+============================+
| beforeCheckAccess    | Срабатывает перед проверкой доступа роли/ресурса           | Да                         |
+----------------------+------------------------------------------------------------+----------------------------+
| afterCheckAccess     | Срабатывает после проверки доступа роли/ресурса            | Нет                        |
+----------------------+------------------------------------------------------------+----------------------------+

В следующем примере показано, как прикрепить слушателей (listeners) к компоненту:

.. code-block:: php

    <?php

    // Создаем менеджер событий
    $eventsManager = new Phalcon\Events\Manager();

    // Прикрепляем слушателя (функцию/callback) к типу "acl"
    $eventsManager->attach("acl", function($event, $acl) {
        if ($event->getType() == 'beforeCheckAccess') {
             echo   $acl->getActiveRole(),
                    $acl->getActiveResource(),
                    $acl->getActiveAccess();
        }
    });

    $acl = new \Phalcon\Acl\Adapter\Memory();

    // Настраиваем $acl
    //...

    // Присваиваем менеджера событий к компоненту ACL
    $acl->setEventsManager($eventManagers);

Реализация собственных адаптеров
--------------------------------
Для создания своего адаптера необходимо реализовать интерфейс :doc:`Phalcon\\Acl\\AdapterInterface <../api/Phalcon_Acl_AdapterInterface>`,
или использовать наследование от существующего адаптера.

.. _Список контроля доступа: http://ru.wikipedia.org/wiki/ACL
