Использование Dependency Injection
**********************************

Следующий пример немного длинный, но объясняет использование контейнера сервисов (service container), service location и dependency injection.
Итак, представим, что мы разрабатываем компонент, назовём его SomeComponent. Сейчас нам не важно, какую именно задачу он выполняет.
Наш компонент имеет некоторую зависимость, отвечающую за соединение с базой данных.

В первом примере соединение устанавливается внутри компонента. Такой подход не является практичным, он не позволяет
нам изменить параметры соединения или тип СУБД, потому как компонент работает только так, как был создан.

.. code-block:: php

    <?php

    class SomeComponent
    {
        /**
         * Объект соединения жестко вписан в компонент,
         * что усложняет его замену на какой-то
         * внешний или изменение его поведения
         */
        public function someDbTask()
        {
            $connection = new Connection(
                array(
                    "host"     => "localhost",
                    "username" => "root",
                    "password" => "secret",
                    "dbname"   => "invo"
                )
            );

            // ...
        }
    }

    $some = new SomeComponent();
    $some->someDbTask();

Чтобы решить эту проблему, создадим сеттер (setter), который внедрит внешнюю зависимость перед использованием.
Теперь это похоже на хорошее решение:

.. code-block:: php

    <?php

    class SomeComponent
    {
        protected $_connection;

        /**
         * Назначает внешнее соединение
         */
        public function setConnection($connection)
        {
            $this->_connection = $connection;
        }

        public function someDbTask()
        {
            $connection = $this->_connection;

            // ...
        }
    }

    $some = new SomeComponent();

    // Создание соединения с БД
    $connection = new Connection(
        array(
            "host"     => "localhost",
            "username" => "root",
            "password" => "secret",
            "dbname"   => "invo"
        )
    );

    // Внедрение соединения в компонент
    $some->setConnection($connection);

    $some->someDbTask();

Теперь примем во внимание тот факт, что мы используем компонент в различных частях приложения,
поэтому появляется необходимость создавать соединение несколько раз и передавать его в компонент.
С помощью некоторого глобального регистра будем получать копию соединения, тем самым нам больше
нет надобности создавать его вновь и вновь:

.. code-block:: php

    <?php

    class Registry
    {
        /**
         * Возвращает соединение
         */
        public static function getConnection()
        {
            return new Connection(
                array(
                    "host"     => "localhost",
                    "username" => "root",
                    "password" => "secret",
                    "dbname"   => "invo"
                )
            );
        }
    }

    class SomeComponent
    {
        protected $_connection;

        /**
         * Sets the connection externally
         */
        public function setConnection($connection)
        {
            $this->_connection = $connection;
        }

        public function someDbTask()
        {
            $connection = $this->_connection;

            // ...
        }
    }

    $some = new SomeComponent();

    // Передает соединение, определяемое в регистре
    $some->setConnection(Registry::getConnection());

    $some->someDbTask();

Теперь представим, что нам необходимо реализовать в компоненте два метода: первый всегда нуждается в создании нового соединения, а второй всегда использует уже установленное (shared):

.. code-block:: php

    <?php

    class Registry
    {
        protected static $_connection;

        /**
         * Создаёт соединение
         */
        protected static function _createConnection()
        {
            return new Connection(
                array(
                    "host"     => "localhost",
                    "username" => "root",
                    "password" => "secret",
                    "dbname"   => "invo"
                )
            );
        }

        /**
         * Создаёт соединение единожды и возвращает его
         */
        public static function getSharedConnection()
        {
            if (self::$_connection===null) {
                $connection = self::_createConnection();
                self::$_connection = $connection;
            }

            return self::$_connection;
        }

        /**
         * Всегда возвращает новое соединение
         */
        public static function getNewConnection()
        {
            return self::_createConnection();
        }
    }

    class SomeComponent
    {
        protected $_connection;

        /**
         * Назначает внешнее соединение
         */
        public function setConnection($connection)
        {
            $this->_connection = $connection;
        }

        /**
         * ля этого метода всегда требуется уже установленное соединение
         */
        public function someDbTask()
        {
            $connection = $this->_connection;

            // ...
        }

        /**
         * Для этого метода всегда требуется новое соединение
         */
        public function someOtherDbTask($connection)
        {

        }
    }

    $some = new SomeComponent();

    // Тут внедряется уже установленное (shared) соединение
    $some->setConnection(Registry::getSharedConnection());

    $some->someDbTask();

    // А здесь всегда в качестве параметра передаётся новое соединение
    $some->someOtherDbTask(Registry::getNewConnection());

До сих пор мы рассматривали случаи, когда внедрение зависимостей решает наши задачи. Передача зависимости в качестве аргументов
вместо создания их внутри кода делает наше приложение более гибким и уменьшает его связанность. Однако, в перспективе,
такая форма внедрения зависимостей имеет некоторые недостатки.

Например, если компонент имеет много зависимостей, мы будем вынуждены создавать сеттеры с множеством аргументов
для передачи зависимостей или конструктор, который принимает их в качестве большого числа аргументов, вдобавок к этому,
всякий раз создавать ещё и сами зависимости до использования компонента. Это сделает наш код слишком сложным для сопровождения:

.. code-block:: php

    <?php

    // Создание зависимостей или получение их из регистра
    $connection = new Connection();
    $session    = new Session();
    $fileSystem = new FileSystem();
    $filter     = new Filter();
    $selector   = new Selector();

    // Передача их в конструктор в качестве параметров
    $some = new SomeComponent($connection, $session, $fileSystem, $filter, $selector);

    // ... или использование сеттеров

    $some->setConnection($connection);
    $some->setSession($session);
    $some->setFileSystem($fileSystem);
    $some->setFilter($filter);
    $some->setSelector($selector);

Думаю, пришлось бы создавать этот объект во многих частях нашего приложения. Если когда-нибудь мы перестанем нуждаться в какой-либо
зависимости, нам придётся пройтись по всем этим местам и удалить соответствующий параметр в вызовах конструктора или сеттерах.
Чтобы решить эту проблему, вернёмся к глобальному регистру для создания компонента. Однако, это добавит новый уровень абстракции,
предшествующий созданию объекта:

.. code-block:: php

    <?php

    class SomeComponent
    {
        // ...

        /**
         * Определение метода factory, который создаёт экземпляр SomeComponent и внедряет в него зависимости
         */
        public static function factory()
        {
            $connection = new Connection();
            $session    = new Session();
            $fileSystem = new FileSystem();
            $filter     = new Filter();
            $selector   = new Selector();

            return new self($connection, $session, $fileSystem, $filter, $selector);
        }
    }

Минуточку, мы снова вернулись туда, откуда начали: создание зависимостей внутри компонента! Мы можем двигаться дальше и находить способ
решать эту проблему каждый раз. Но, это означает, что мы снова и снова будем наступать на те же грабли.

Практически применимый и элегантный способ решить эту проблему — это использовать контейнер для зависимостей. Он играет ту же роль, что и
глобальный регистр, который мы видели выше. Использование контейнера в качестве моста к зависимостям позволяет нам уменьшить сложность
нашего компонента:

.. code-block:: php

    <?php

    use Phalcon\DI;

    class SomeComponent
    {
        protected $_di;

        public function __construct($di)
        {
            $this->_di = $di;
        }

        public function someDbTask()
        {
            // Получение сервиса соединений
            // Всегда возвращает соединение
            $connection = $this->_di->get('db');
        }

        public function someOtherDbTask()
        {
            // Получение сервиса соединения, предназначенного для общего доступа,
            // всегда возвращает одно и то же соединение
            $connection = $this->_di->getShared('db');

            // Этот метод так же требует сервиса фильтрации входных данных
            $filter = $this->_di->get('filter');
        }
    }

    $di = new DI();

    // Регистрация в контейнере сервиса "db"
    $di->set('db', function () {
        return new Connection(
            array(
                "host"     => "localhost",
                "username" => "root",
                "password" => "secret",
                "dbname"   => "invo"
            )
        );
    });

    // Регистрация в контейнере сервиса "filter"
    $di->set('filter', function () {
        return new Filter();
    });

    // Регистрация в контейнере сервиса "session"
    $di->set('session', function () {
        return new Session();
    });

    // Передача контейнера сервисов в качестве единственного параметра
    $some = new SomeComponent($di);

    $some->someDbTask();

Теперь компонент имеет простой доступ к сервисам, которые ему необходимы. Если сервис не востребован, он не будет инициализирован,
тем самым экономя ресурсы. Так же компонент теперь обладает низкой связанностью. Например, можно заменить способ создания соединений,
поведение или любой другой аспект их работы, и это никак не отразится на компоненте.

Наш подход
==========
Phalcon\\DI — это компонент, реализующий Dependency Injection и Location сервисов и является контейнером для них.

Поскольку Phalcon обладает низкой связанностью, Phalcon\\DI необходимо обеспечить интеграцию различных компонентов фреймворка.
Разработчики так же могут использовать этот компонент для внедрения зависимостей и использования глобальных экземпляров различных классов, используемых в приложении.

В основе своей, компонент реализует паттерн `Инверсии управления`_. Применяя его, объекты получают их зависимости не с использованием сеттеров или конструкторов,
а с помощью сервиса внедрения зависимостей. Это снижает общую сложность, поскольку остаётся только один способ получения зависимостей в компоненте.

К тому же, этот паттерн увеличивает тестируемость в коде, что позволяет снизить "ошибочность" кода.

Регистрация сервисов в Контейнере сервисов
==========================================
Регистрация сервисов возможна как разработчиком, так и самим фреймворком. Когда компоненту A требуется компонент B (или экземпляр его класса) для работы,
он может запросить его из контейнера, а не создавать новый экземпляр.

Такой способ работы даёт нам много преимуществ:

* Мы можем легко заменять компонент на созданный нами или кем-то другим.
* Мы обладаем полным контролем над инициализацией объекта, что позволяет нам настраивать эти объекты так, как нам необходимо, прежде, чем передать их компонентам.
* Мы можем получать глобальный экземпляр компонента структурированным и унифицированным образом.

Зарегистрировать сервисы можно несколькими различными способами:

.. code-block:: php

    <?php

    use Phalcon\Http\Request;

    // Создание контейнера Dependency Injector
    $di = new Phalcon\DI();

    // По названию класса
    $di->set("request", 'Phalcon\Http\Request');

    // С использованием анонимной функции для отложенной загрузки
    $di->set("request", function () {
        return new Request();
    });

    // Регистрация экземпляра напрямую
    $di->set("request", new Request());

    // Определение с помощью массива
    $di->set(
        "request",
        array(
            "className" => 'Phalcon\Http\Request'
        )
    );

Для регистрации сервисов можно так же использовать синтаксис массивов:

.. code-block:: php

    <?php

    use Phalcon\Http\Request;

    // Создание контейнера DI
    $di = new Phalcon\DI();

    // По названию класса
    $di["request"] = 'Phalcon\Http\Request';

    // С использованием анонимной функции для отложенной загрузки
    $di["request"] = function () {
        return new Request();
    };

    // Регистрация экземпляра напрямую
    $di["request"] = new Request();

    // Определение с помощью массива
    $di["request"] = array(
        "className" => 'Phalcon\Http\Request'
    );

В примере, данном выше, когда фреймворк нуждается в доступе к запрашиваемым данным, он будет запрашивать в контейнере сервис, названный 'request'.
Контейнер, в свою очередь, возвращает экземпляр затребованного сервиса. Разработчик, в конечном итоге, может заменить компонент, когда захочет.

Каждый из методов регистрации сервисов имеет свои достоинства и недостатки. Какой из них использовать — зависит только от разработчика и
от конкретных требований.

Назначение сервиса строкой очень простое, но лишено гибкости. В качестве массива — предоставляет большую гибкость, но делает код менее понятным.
Анонимные функции неплохо балансируют между этими двумя способами, но им может потребоваться больше обслуживания, чем это ожидается.

Phalcon\\DI предоставляет отложенную загрузку для каждого хранимого им сервиса. Если разработчик не решит создавать экземпляр объекта напрямую и
хранить его в контейнере, любой объект сохранённый в нём (через массив, строку и т.д.) будет загружен отложенно (lazy load), т.е. создастся только тогда, когда будет востребован.

Простая регистрация
-------------------
Как было показано выше, есть несколько способов для регистрации сервисов. Следующие из них мы называем "простыми":

Строчный
^^^^^^^^
Этот способ ожидает в качестве параметра имя существующего класса, возвращает его объект, если класс не был загружен автолоадером.
Такой способ не позволяет передавать аргументы для конструктора класса или настраивать параметры:

.. code-block:: php

    <?php

    // Возвращает новый Phalcon\Http\Request();
    $di->set('request', 'Phalcon\Http\Request');

Объект
^^^^^^
Этот способ в качестве параметра принимает объект. Объект не нуждается в создании, потому как объект
уже является объектом сам по себе. Вообще говоря, в данном случае это не является настоящим внедрением
зависимости, однако такой способ вполне используем, если вы хотите быть уверены в том, что возвращаемая
зависимость всегда будет одним и тем же объектом/значением:

.. code-block:: php

    <?php

    use Phalcon\Http\Request;

    // Возвращает новый Phalcon\Http\Request();
    $di->set('request', new Request());

Замыкания/Анонимные функции
^^^^^^^^^^^^^^^^^^^^^^^^^^^
Этот метод дает больше свободы для построения зависимости, если этого захотеть, тем не менее, он весьма
сложен в плане изменения некоторых параметров извне без полного замещения определения зависимости:

.. code-block:: php

    <?php

    use Phalcon\Db\Adapter\Pdo\Mysql as PdoMysql;

    $di->set("db", function () {
        return new PdoMysql(
            array(
                "host"     => "localhost",
                "username" => "root",
                "password" => "secret",
                "dbname"   => "blog"
            )
        );
    });

Некоторые ограничения можно преодолеть путём передачи дополнительных переменных в область видимости замыкания:

.. code-block:: php

    <?php

    use Phalcon\Db\Adapter\Pdo\Mysql as PdoMysql;

    // Using the $config variable in the current scope
    $di->set("db", function () use ($config) {
        return new PdoMysql(
            array(
                "host"     => $config->host,
                "username" => $config->username,
                "password" => $config->password,
                "dbname"   => $config->name
            )
        );
    });

Сложная регистрация
-------------------
Если потребуется изменить определение сервиса без создания экземпляра, тогда нам придётся определять его
с использованием синтаксиса массивов. Такое определение может оказаться чуть более длинным:

.. code-block:: php

    <?php

    use Phalcon\Logger\Adapter\File as LoggerFile;

    // Регистрация сервиса 'logger' с помощью имени класса и параметров для него
    $di->set('logger', array(
        'className' => 'Phalcon\Logger\Adapter\File',
        'arguments' => array(
            array(
                'type'  => 'parameter',
                'value' => '../apps/logs/error.log'
            )
        )
    ));

    // Или в виде анонимной функции
    $di->set('logger', function () {
        return new LoggerFile('../apps/logs/error.log');
    });

Оба способа приведут к одинаковому результату. Определение же с помощью массива позволяет изменение параметров, если это необходимо:

.. code-block:: php

    <?php

    // Изменение названия класса для сервиса
    $di->getService('logger')->setClassName('MyCustomLogger');

    // Изменение первого параметра без пересоздания экземпляра сервиса logger
    $di->getService('logger')->setParameter(0, array(
        'type'  => 'parameter',
        'value' => '../apps/logs/error.log'
    ));

В дополнение к этому, используя синтаксис массивов, можно использовать три типа внедрения зависимостей:

Constructor Injection
^^^^^^^^^^^^^^^^^^^^^
Этот тип передаёт зависимости/аргументы в конструктор класса.
Представим, что у нас есть следующий компонент:

.. code-block:: php

    <?php

    namespace SomeApp;

    use Phalcon\Http\Response;

    class SomeComponent
    {
        protected $_response;

        protected $_someFlag;

        public function __construct(Response $response, $someFlag)
        {
            $this->_response = $response;
            $this->_someFlag = $someFlag;
        }
    }

Сервис может быть зарегистрирован следующим образом:

.. code-block:: php

    <?php

    $di->set('response', array(
        'className' => 'Phalcon\Http\Response'
    ));

    $di->set('someComponent', array(
        'className' => 'SomeApp\SomeComponent',
        'arguments' => array(
            array('type' => 'service', 'name' => 'response'),
            array('type' => 'parameter', 'value' => true)
        )
    ));

Сервис "response" (Phalcon\\Http\\Response) передаётся в конструктор в качестве первого параметра,
в то время как вторым параметром передаётся булевое значение (true) без изменений.

Setter Injection
^^^^^^^^^^^^^^^^
Классы могут иметь сеттеры для внедрения дополнительных зависимостей. Наш предыдущий класс может быть изменён, чтобы принимать зависимости с помощью сеттеров:

.. code-block:: php

    <?php

    namespace SomeApp;

    use Phalcon\Http\Response;

    class SomeComponent
    {
        protected $_response;

        protected $_someFlag;

        public function setResponse(Response $response)
        {
            $this->_response = $response;
        }

        public function setFlag($someFlag)
        {
            $this->_someFlag = $someFlag;
        }
    }

Сервис с сеттерами для зависимостей может быть зарегистрирован следующим образом:

.. code-block:: php

    <?php

    $di->set('response', array(
        'className' => 'Phalcon\Http\Response'
    ));

    $di->set(
        'someComponent',
        array(
            'className' => 'SomeApp\SomeComponent',
            'calls'     => array(
                array(
                    'method'    => 'setResponse',
                    'arguments' => array(
                        array(
                            'type' => 'service',
                            'name' => 'response'
                        )
                    )
                ),
                array(
                    'method'    => 'setFlag',
                    'arguments' => array(
                        array(
                            'type'  => 'parameter',
                            'value' => true
                        )
                    )
                )
            )
        )
    );

Properties Injection
^^^^^^^^^^^^^^^^^^^^
Менее распространённым способом является внедрение зависимостей или полей класса напрямую:

.. code-block:: php

    <?php

    namespace SomeApp;

    use Phalcon\Http\Response;

    class SomeComponent
    {
        public $response;

        public $someFlag;
    }

Сервис с прямым внедрением может быть зарегистрирован следующим способом:

.. code-block:: php

    <?php

    $di->set(
        'response',
        array(
            'className' => 'Phalcon\Http\Response'
        )
    );

    $di->set(
        'someComponent',
        array(
            'className'  => 'SomeApp\SomeComponent',
            'properties' => array(
                array(
                    'name'  => 'response',
                    'value' => array(
                        'type' => 'service',
                        'name' => 'response'
                    )
                ),
                array(
                    'name'  => 'someFlag',
                    'value' => array(
                        'type'  => 'parameter',
                        'value' => true
                    )
                )
            )
        )
    );

Поддерживаются параметры следующих типов:

+-------------+----------------------------------------------------------+-------------------------------------------------------------------------------------+
| Тип         | Описание                                                 | Пример                                                                              |
+=============+==========================================================+=====================================================================================+
| parameter   | Буквенное значение, передаваемое в качестве параметра    | array('type' => 'parameter', 'value' => 1234)                                       |
+-------------+----------------------------------------------------------+-------------------------------------------------------------------------------------+
| service     | Другой сервис в контейнере                               | array('type' => 'service', 'name' => 'request')                                     |
+-------------+----------------------------------------------------------+-------------------------------------------------------------------------------------+
| instance    | Объект, который должен создаваться динамически           | array('type' => 'instance', 'className' => 'DateTime', 'arguments' => array('now')) |
+-------------+----------------------------------------------------------+-------------------------------------------------------------------------------------+

Получение сервисов, определение которых весьма сложно может быть немного медленнее, чем рассмотренные выше определения.
Однако, это предоставляет больше возможностей для определения и внедрения сервисов.

Можно совмещать различные типы определения, определяя для себя наиболее подходящий способ регистрации сервиса в соответствии
с потребностями приложения.

Доступ к сервисам
=================
Получение сервиса из контейнера очень просто производится вызовом метода "get". Будет возвращен новый экземпляр сервиса:

.. code-block:: php

    <?php $request = $di->get("request");

Так же можно вызвать магический метод:

.. code-block:: php

    <?php

    $request = $di->getRequest();

Или использовать доступ как к массиву:

.. code-block:: php

    <?php

    $request = $di['request'];

Аргументы могут быть переданы в конструктор добавлением массива параметров в метод "get":

.. code-block:: php

    <?php

    // новый MyComponent("some-parameter", "other")
    $component = $di->get("MyComponent", array("some-parameter", "other"));

Events
^^^^^^
:doc:`Phalcon\\Di <../api/Phalcon_DI>` is able to send events to an :doc:`EventsManager <events>` if it is present.
Events are triggered using the type "di". Some events when returning boolean false could stop the active operation.
The following events are supported:

+----------------------+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------+
| Event Name           | Triggered                                                                                                                       | Can stop operation? | Triggered on       |
+======================+=================================================================================================================================+=====================+====================+
| beforeServiceResolve | Triggered before resolve service. Listeners receive the service name and the parameters passed to it.                           | No                  | Listeners          |
+----------------------+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------+
| afterServiceResolve  | Triggered after resolve service. Listeners receive the service name, instance, and the parameters passed to it.                 | No                  | Listeners          |
+----------------------+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------+

Совместный доступ к сервисам
============================
Сервисы могут быть сразу зарегистрированы, как предназначенные для совместного ("shared") доступа. Это означает, что они всегда будут синглетонами
(singletons_). После того, как этот сервис будет один раз создан, всегда будет возвращаться тот же самый его экземпляр:

.. code-block:: php

    <?php

    use Phalcon\Session\Adapter\Files as SessionFiles;

    // Регистрация сервиса сессий, как "always shared"
    $di->setShared('session', function () {
        $session = new SessionFiles();
        $session->start();
        return $session;
    });

    $session = $di->get('session'); // Locates the service for the first time
    $session = $di->getSession();   // Returns the first instantiated object

Так же можно зарегистрировать сервис с совместным доступом, передав "true" в качестве третьего параметра метода "set":

.. code-block:: php

    <?php

    // Регистрация сервиса сессий, как "always shared"
    $di->set('session', function () {
        // ...
    }, true);

Если сервис не был зарегистрирован для общего доступа и вы хотите всё же получать один и тот же экземпляр каждый раз,
то можно получать его, используя метод DI "getShared":

.. code-block:: php

    <?php

    $request = $di->getShared("request");

Ручное управление сервисами
===========================
После того, как сервис был зарегистрирован в контейнере, вы можете управлять им вручную:

.. code-block:: php

    <?php

    use Phalcon\Http\Request;

    // Регистрация сервиса сессий
    $di->set('request', 'Phalcon\Http\Request');

    // Получение сервиса
    $requestService = $di->getService('request');

    // Изменение его определение
    $requestService->setDefinition(function () {
        return new Request();
    });

    // Назначение его как "always shared"
    $requestService->setShared(true);

    // Получение сервиса (возвращает экземпляр Phalcon\Http\Request)
    $request = $requestService->resolve();

Создание экземпляров классов через контейнер сервисов
======================================================
Когда вы запрашиваете какой-то сервис из контейнера, и он не может найти его по такому имени, контейнер пытается загрузить класс с таким
же названием. С помощью этого вы можете легко заменить какой-либо класс на любой другой, зарегистрировав сервис с таким же названием:

.. code-block:: php

    <?php

    // Регистрация контроллера как сервиса
    $di->set('IndexController', function () {
        $component = new Component();
        return $component;
    }, true);

    // Регистрация компонента как сервиса
    $di->set('MyOtherComponent', function () {
        // Actually returns another component
        $component = new AnotherComponent();
        return $component;
    });

    // Создание экземпляра объекта с помощью контейнера сервисов
    $myComponent = $di->get('MyOtherComponent');

Вы можете пользоваться этим, всегда создавая экземпляры объектов ваших классов с помощью контейнера сервисов (даже если они не регистрировались как сервисы).
DI будет запускать правильный автозагрузчик для того, чтобы в итоге загрузить класс. Делая так, вы сможете легко заменить любой класс в будущем, реализовав
его определение.

Автоматическое внедрение DI
===========================
Если класс или компонент требует DI для нахождения сервисов, DI может автоматически внедрить себя в экземпляры этих компонентов или объектов,
чтобы сделать это вам необходимо реализовать :doc:`Phalcon\\DI\\InjectionAwareInterface <../api/Phalcon_DI_InjectionAwareInterface>` в своём классе:

.. code-block:: php

    <?php

    use Phalcon\DI\InjectionAwareInterface;

    class MyClass implements InjectionAwareInterface
    {
        protected $_di;

        public function setDi($di)
        {
            $this->_di = $di;
        }

        public function getDi()
        {
            return $this->_di;
        }
    }

Когда сервис будет запрошен, $di будет передан в setDi автоматически:

.. code-block:: php

    <?php

    // Регистрация сервиса
    $di->set('myClass', 'MyClass');

    // Получение сервиса (ВНИМАНИЕ: $myClass->setDi($di) вызовется автоматически)
    $myClass = $di->get('myClass');

Избежание разрешения сервисов
=============================
Сервисы, которые используются при каждом обращении к приложению, могут избежать процесса их разрешения, что может немного
увеличить производительность:

.. code-block:: php

    <?php

    // Внешнее разрешение объекта вместо его определения
    $router = new MyRouter();

    // Передача уже созданного объекта
    $di->set('router', $router);

Размещение сервисов в файлах
============================
Вы можете улучшить организацию вашего приложения переместив регистрацию сервисов в отдельные файлы, которые
делают всё, что происходит при старте приложения:

.. code-block:: php

    <?php

    $di->set('router', function () {
        return include "../app/config/routes.php";
    });

А файл "../app/config/routes.php" вернёт готовый объект:

.. code-block:: php

    <?php

    $router = new MyRouter();

    $router->post('/login');

    return $router;

Статический доступ к DI
=======================
При необходимости вы можете получить доступ к последнему созданному DI в статической функции следующим образом:

.. code-block:: php

    <?php

    use Phalcon\DI;

    class SomeComponent
    {
        public static function someMethod()
        {
            // Получение сервиса сессий
            $session = DI::getDefault()->getSession();
        }
    }

Factory Default DI
==================
Несмотря на то, что разрозненный характер Phalcon дарит нам огромную свободу и гибкость, возможно мы захотим легко использовать полноценный
фреймворк. Для достижения этой цели фреймворк предоставляет Phalcon\\DI называющийся Phalcon\\DI\\FactoryDefault. Этот класс автоматически
регистрирует такие сервисы, которые обычно определены в полноценном фреймворке.

.. code-block:: php

    <?php

    use Phalcon\DI\FactoryDefault;

    $di = new FactoryDefault();

Соглашение именования сервисов
==============================
Хотя, вы и можете регистрировать сервисы с любыми именами, какие вам только понравятся, Phalcon имеет некоторое соглашение
именования сервисов, что позволяет ему правильно работать с сервисами, когда они вам необходимы.

+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| Название сервиса    | Описание                                    | По умолчанию                                                                                       | Общий доступ |
+=====================+=============================================+====================================================================================================+==============+
| dispatcher          | Диспетчер контроллеров                      | :doc:`Phalcon\\Mvc\\Dispatcher <../api/Phalcon_Mvc_Dispatcher>`                                    | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| router              | Роутер                                      | :doc:`Phalcon\\Mvc\\Router <../api/Phalcon_Mvc_Router>`                                            | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| url                 | Генератор URL'ов                            | :doc:`Phalcon\\Mvc\\Url <../api/Phalcon_Mvc_Url>`                                                  | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| request             | Окружение HTTP запросов                     | :doc:`Phalcon\\Http\\Request <../api/Phalcon_Http_Request>`                                        | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| response            | Окружение HTTP ответов                      | :doc:`Phalcon\\Http\\Response <../api/Phalcon_Http_Response>`                                      | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| cookies             | Сервис управления HTTP Cookies              | :doc:`Phalcon\\Http\\Response\\Cookies <../api/Phalcon_Http_Response_Cookies>`                     | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| filter              | Входной фильтр                              | :doc:`Phalcon\\Filter <../api/Phalcon_Filter>`                                                     | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| flash               | Всплывающие сообщения                       | :doc:`Phalcon\\Flash\\Direct <../api/Phalcon_Flash_Direct>`                                        | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| flashSession        | Сессия всплывающих сообщений                | :doc:`Phalcon\\Flash\\Session <../api/Phalcon_Flash_Session>`                                      | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| session             | Сессия                                      | :doc:`Phalcon\\Session\\Adapter\\Files <../api/Phalcon_Session_Adapter_Files>`                     | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| eventsManager       | Управление событиями                        | :doc:`Phalcon\\Events\\Manager <../api/Phalcon_Events_Manager>`                                    | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| db                  | Низкоуровневый коннектор к базе данных      | :doc:`Phalcon\\Db <../api/Phalcon_Db>`                                                             | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| security            | Помощник безопасности                       | :doc:`Phalcon\\Security <../api/Phalcon_Security>`                                                 | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| crypt               | Шифрование/Дешифрование данных              | :doc:`Phalcon\\Crypt <../api/Phalcon_Crypt>`                                                       | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| tag                 | генератор HTML конструкций                  | :doc:`Phalcon\\Tag <../api/Phalcon_Tag>`                                                           | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| escaper             | Контекстное экранирование                   | :doc:`Phalcon\\Escaper <../api/Phalcon_Escaper>`                                                   | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| annotations         | Парсер аннотаций                            | :doc:`Phalcon\\Annotations\\Adapter\\Memory <../api/Phalcon_Annotations_Adapter_Memory>`           | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| modelsManager       | Управление моделями                         | :doc:`Phalcon\\Mvc\\Model\\Manager <../api/Phalcon_Mvc_Model_Manager>`                             | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| modelsMetadata      | Мета-данные моделей                         | :doc:`Phalcon\\Mvc\\Model\\MetaData\\Memory <../api/Phalcon_Mvc_Model_MetaData_Memory>`            | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| transactionManager  | Управление транзакциями моделей             | :doc:`Phalcon\\Mvc\\Model\\Transaction\\Manager <../api/Phalcon_Mvc_Model_Transaction_Manager>`    | Да           |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| modelsCache         | Кэширование для моделей                     | None                                                                                               | -            |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+
| viewsCache          | Кэширование для частичных представлений     | None                                                                                               | -            |
+---------------------+---------------------------------------------+----------------------------------------------------------------------------------------------------+--------------+

Реализация собственного DI
==========================
Для создания собственного DI необходимо реализовать интерфейс :doc:`Phalcon\\DiInterface <../api/Phalcon_DiInterface>`, или использовать наследование и переопределить стандартный компонент Phalcon.

.. _`Инверсии управления`: http://en.wikipedia.org/wiki/Inversion_of_control
.. _Singletons: http://en.wikipedia.org/wiki/Singleton_pattern
