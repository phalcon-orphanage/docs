Заголовки ответа (Response)
===========================

Одной из частей работы HTTP-протокола является возвращение ответа клиенту. В Phalcon существует компонент :doc:`Phalcon\\Http\\Response <../api/Phalcon_Http_Response>`
для реализации этой задачи. Чаще всего HTTP-ответ состоит из заголовков и тела ответа. Типичное использование Response выглядит следующим образом:

.. code-block:: php

    <?php

    use Phalcon\Http\Response;

    // Получение экземпляра Response
    $response = new Response();

    // Установка кода статуса
    $response->setStatusCode(404, "Not Found");

    // Установка содержимого ответа
    $response->setContent("Сожалеем, но страница не существует");

    // Отправка ответа клиенту
    $response->send();

Имейте в виду, что при использовании полного стека MVC нет необходимости отправлять результаты Response вручную. Однако, если есть необходимость указать ответ самостоятельно
в действии контроллера, то можно использовать такой пример:

.. code-block:: php

    <?php

    use Phalcon\Http\Response;
    use Phalcon\Mvc\Controller;

    class FeedController extends Controller
    {
        public function getAction()
        {
            // Получение экземпляра Response
            $response = new Response();

            $feed = // .. тут данные

            // Установка содержимого ответа
            $response->setContent(
                $feed->asString()
            );

            // Возврат Response ответа
            return $response;
        }
    }

Работа с заголовками
--------------------
Заголовки являются важной частью для HTTP-ответов. Они содержат полезную информацию о статусе ответа, его типе и еще многое другое.

Указывать заголовки можно следующим образом:

.. code-block:: php

    <?php

    // Установка по имени
    $response->setHeader("Content-Type", "application/pdf");
    $response->setHeader("Content-Disposition", 'attachment; filename="downloaded.pdf"');

    // Установка напрямую
    $response->setRawHeader("HTTP/1.1 200 OK");

Объект :doc:`Phalcon\\Http\\Response\\Headers <../api/Phalcon_Http_Response_Headers>` содержит в себе все заголовки и средства для их управления.
Этот класс позволяет управлять заголовками до их отправки клиенту:

.. code-block:: php

    <?php

    // Получение всех заголовков
    $headers = $response->getHeaders();

    // Получение заголовка по имени
    $contentType = $headers->get("Content-Type");

Создание перенаправлений (редиректы)
------------------------------------
С помощью :doc:`Phalcon\\Http\\Response <../api/Phalcon_Http_Response>` вы можете выполнять переадресования HTTP:

.. code-block:: php

    <?php

    // Переадресация на корневой URI
    $response->redirect();

    // Перенаправление на внутренний URI
    $response->redirect("posts/index");

    // Перенаправление на внешнюю ссылку
    $response->redirect("http://en.wikipedia.org", true);

    // Перенаправление со специальным HTTP-кодом
    $response->redirect("http://www.example.com/new-location", true, 301);

Все ссылки обслуживаются внутренним сервисом 'url' (по умолчанию это :doc:`Phalcon\\Mvc\\Url <url>`), в таком случае вы можете использовать
перенаправления на определённые в приложении маршруты (роуты):

.. code-block:: php

    <?php

    // Переадресация по именованному правилу роутинга
    return $response->redirect(
        [
            "for"        => "index-lang",
            "lang"       => "jp",
            "controller" => "index",
        ]
    );

Обратите внимание, что при создании перенаправления не отключается компонент отображения (Views), так что действие, в котором
оно вызывается, всё равно будет выполнено. Вы можете отключить отображение из контроллера, выполнив :code:`$this->view->disable()`;

HTTP-кэширование
----------------
Одним из самых простых способов повышения производительности приложения является снижение трафика с помощью HTTP-кэширования.
Большинство современных браузеров поддерживают HTTP-кэширование и это является одной из причин, почему многие веб-сайты в настоящее
время работают достаточно быстро.

Поведение HTTP-кэша может быть изменено с помощью заголовков, отправляемых при первой передаче страницы:

* *Expires:* Устанавливая этот заголовок в прошлое или будущее можно указывать браузеру срок жизни страницы.
* *Cache-Control:* Позволяет указать сколько времени страница должна считаться для браузера актуальной.
* *Last-Modified:* Указывает браузеру когда было последнее изменение страницы, что позволяет избежать повторной загрузки страницы.
* *ETag:* Представляет собой уникальный идентификатор, который должен быть сформирован с учетом времени изменения текущей страницы.

Expires
^^^^^^^
Указание срока жизни является одним из наиболее удобных и эффективных способов кэширования страниц на стороне клиента (браузера).
Мы добавим дополнительный срок к текущему времени, это укажет браузеру сохранять страницу в кэше пока этот срок не истечет
и не обращаться за ней к серверу:

.. code-block:: php

    <?php

    $expiryDate = new DateTime();
    $expiryDate->modify("+2 months");

    $response->setExpires($expiryDate);

Ответ в компоненте Response автоматически преобразует дату для временной зоны GMT, именно так как ожидается в заголовке Expires.

Более того, если мы укажем прошедшую дату, то это указывает браузеру всегда обновлять запрошенную страницу:

.. code-block:: php

    <?php

    $expiryDate = new DateTime();
    $expiryDate->modify("-10 minutes");

    $response->setExpires($expiryDate);

Браузеры основываются на системных часах клиента для определения наступления этой даты. Так как часы на клиенте могут быть изменены, то
срок жизни будет некорректен. Это ограничение такого механизма кэширования.

Cache-Control
^^^^^^^^^^^^^
Этот заголовок осуществляет более безопасный способ кэширования. Мы просто указываем браузеру время в секундах которое необходимо
хранить страницы в кэше:

.. code-block:: php

    <?php

    // кэшировать на сутки с текущего момента
    $response->setHeader("Cache-Control", "max-age=86400");

Противоположный эффект (для запрета кэширования страницы) организуется следующим образом:

.. code-block:: php

    <?php

    // Не кэшировать
    $response->setHeader("Cache-Control", "private, max-age=0, must-revalidate");

E-Tag
^^^^^
Заголовок "entity-tag" или кратко "E-tag" позволяет браузеру понять, была ли изменена страница между двумя запросами.
Идентификатор должен рассчитываться таким образом, что бы измениться если изменено содержимое страницы:

.. code-block:: php

    <?php

    // Формирование значения E-Tag основанное на последнем времени изменения новости
    $mostRecentDate = News::maximum(
        [
            "column" => "created_at"
        ]
    );

    $eTag = md5($mostRecentDate);

    // Отправка E-Tag
    $response->setHeader("E-Tag", $eTag);
