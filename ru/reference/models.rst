Работа с моделями
=================

Модель представляет собой информацию (данные) приложения и правила для манипуляции этими данными. Модели в основном используются для управления
правилами взаимодействия с соответствующими таблицами базы данных. В большинстве случаев, каждая таблица в вашей базе данных соответствует одной модели в
вашем приложении. Большая часть всей бизнес-логики вашего приложения будет сосредоточена в моделях.

:doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` является родительским классом. Когда процесс выполняет несколько операций для всех моделей в вашем приложении Phalcon. Он обеспечивает независимость данных от вашей базы, основные
CRUD операции, расширенные поисковые возможности, а также возможность построения зависимостей между моделями.
:doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` исключает необходимость использования SQL запросов, потому как данный класс динамически переводит
методы на соответствующие им операции СУБД.

.. highlights::

    Модели предназначены для работы с базой данных на высшем уровне абстракции. Если вы испытваете потребность в работе с базой данных на низшем уровне, обратитесь к
    документации компонента :doc:`Phalcon\\Db <../api/Phalcon_Db>`.

Создание модели
---------------
Модель это класс, который расширяет :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>`. Его имя должно быть записано в CamelCase стиле:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {

    }

.. highlights::

    Если вы используете PHP 5.4/5.5 рекомендовано объявлять каждый столбец базы данных, который входит в модель в целях экономии
    памяти и уменьшения общего выделения памяти на выполнение.

По умолчанию модель "Store\\Toys\\Robots" будет ссылаться на таблицу 'robots'. Если вы захотите вручную указать другое имя для маппинга таблицы,
вы можете использовать метод :code:`setSource()`:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public function initialize()
        {
            $this->setSource("toys_robots");
        }
    }

Теперь модель Robots отображается на таблицу "toys_robots". Метод :code:`initialize()` помогает в создании модели с пользовательским поведением, т.е. использовании другой таблицы.

Метод :code:`initialize()` вызывается один раз при обработке запроса к приложению и предназначен для инициализации
экземпляров модели в приложении. Если вам необходимо произвести некоторые настройки экземпляра объекта
после того, как он создан, вы можете использовать метод :code:`onConstruct()`:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public function onConstruct()
        {
            // ...
        }
    }

Публичные свойства и сеттеры/геттеры
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Модели могут быть реализованы с помощью свойств с общим доступом (public), при этом свойства модели доступны для чтения/изменения
из любой части кода без ограничений:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public $id;

        public $name;

        public $price;
    }

При использовании геттеров и сеттеров вы можете полностью контролировать видимость свойств, их обработку
и, например, применять различную валидацию при сохранении объекта:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use InvalidArgumentException;
    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        protected $id;

        protected $name;

        protected $price;

        public function getId()
        {
            return $this->id;
        }

        public function setName($name)
        {
            // Имя слишком короткое?
            if (strlen($name) < 10) {
                throw new InvalidArgumentException(
                    "Имя слишком короткое"
                );
            }

            $this->name = $name;
        }

        public function getName()
        {
            return $this->name;
        }

        public function setPrice($price)
        {
            // Не разрешаем отрицательные цены
            if ($price < 0) {
                throw new InvalidArgumentException(
                    "Цена не может быть отрицательной"
                );
            }

            $this->price = $price;
        }

        public function getPrice()
        {
            // Преобразование значение в double (формат числа с плавающей запятой), прежде чем использовать
            return (double) $this->price;
        }
    }

Публичные свойства облегчают создание кода. Напротив, применение геттеров/сеттеров делает ваш код тестируемым,
расширяемым и удобным в сопровождении. Разработчик вправе сам определить способ описания модели.
ORM совместим с обоими способами.

.. highlights::

    Underscores in property names can be problematic when using getters and setters.

If you use underscores in your property names, you must still use camel case in your getter/setter declarations for use
with magic methods. (e.g. $model->getPropertyName instead of $model->getProperty_name, $model->findByPropertyName
instead of $model->findByProperty_name, etc.). As much of the system expects camel case, and underscores are commonly
removed, it is recommended to name your properties in the manner shown throughout the documentation. You can use a
column map (as described above) to ensure proper mapping of your properties to their database counterparts.

Понимание записей в объектах
----------------------------
Каждый экземпляр объекта модели представляет собой строку таблицы базы данных. Вы можете легко получить доступ к любой записи, считывая свойство объекта. К примеру,
для таблицы "robots" с записями:

.. code-block:: bash

    mysql> select * from robots;
    +----+------------+------------+------+
    | id | name       | type       | year |
    +----+------------+------------+------+
    |  1 | Robotina   | mechanical | 1972 |
    |  2 | Astro Boy  | mechanical | 1952 |
    |  3 | Terminator | cyborg     | 2029 |
    +----+------------+------------+------+
    3 rows in set (0.00 sec)

Вы можете найти определенную запись по ее первичному ключу и напечатать ее имя:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    // Найти запись с id = 3
    $robot = Robots::findFirst(3);

    // Печатать "Terminator"
    echo $robot->name;

Как только запись будет зарезервирована в памяти, мы можете производить изменения ее данных, а затем сохранить изменения.

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = Robots::findFirst(3);

    $robot->name = "RoboCop";

    $robot->save();

Как вы можете видеть, нет никакой необходимости в использовании необработанных SQL запросов. :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` предоставляет высший
уровень абстракции базы данных для веб-приложений.

Поиск записей
-------------
:doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` также предлагает несколько методов для выборки записей. В следующем примере мы покажем вам
как запросить одну или несколько записей из модели:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    // Сколько роботов есть?
    $robots = Robots::find();
    echo "Найдено роботов: ", count($robots), "\n";

    // Сколько существует механических роботов?
    $robots = Robots::find("type = 'mechanical'");
    echo "Найдено роботов: ", count($robots), "\n";

    // Получить и распечатать виртуальных роботов упорядоченные по имени
    $robots = Robots::find(
        [
            "type = 'virtual'",
            "order" => "name",
        ]
    );
    foreach ($robots as $robot) {
        echo $robot->name, "\n";
    }

    // Получить первые 100 виртуальных роботов упорядоченных по имени
    $robots = Robots::find(
        [
            "type = 'virtual'",
            "order" => "name",
            "limit" => 100,
        ]
    );
    foreach ($robots as $robot) {
       echo $robot->name, "\n";
    }

.. highlights::

    Для исключения SQL-инъекций при поиске записей на основе пользовательского ввода или переменных вы должны использовать привязку параметров (см. ниже).

Вы также можете использовать метод :code:`findFirst()`, чтобы получить только первую запись для данного критерия:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    // Первый робот в таблице роботов
    $robot = Robots::findFirst();
    echo "Название робота: ", $robot->name, "\n";

    // Первый  механический робот в таблице роботов
    $robot = Robots::findFirst("type = 'mechanical'");
    echo "Название первого механического робота: ", $robot->name, "\n";

    // Получим первого виртуального робота, упорядочив результат по имени
    $robot = Robots::findFirst(
        [
            "type = 'virtual'",
            "order" => "name",
        ]
    );
    echo "Название первого виртуального робота: ", $robot->name, "\n";

Оба метода :code:`find()` и :code:`findFirst()` принимают ассоциативный массив, определяющий критерии поиска:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = Robots::findFirst(
        [
            "type = 'virtual'",
            "order" => "name DESC",
            "limit" => 30,
        ]
    );

    $robots = Robots::find(
        [
            "conditions" => "type = ?1",
            "bind"       => [
                1 => "virtual",
            ]
        ]
    );

Доступные параметры запроса:

+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------+
| Параметр    | Описание                                                                                                                                                                                                                                         | Пример                                                                  |
+=============+==================================================================================================================================================================================================================================================+=========================================================================+
| conditions  | Условие поиска. Он используется для выделения только тех записей, которые полностью удовлетворяют условиям поиска. По умолчанию :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` предполагает что первый параметр является условием поиска  | :code:`"conditions" => "name LIKE 'steve%'"`                            |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------+
| columns     | Используется для указания списка столбцов возвращаемого в модели. Объект будет не полным при использовании этого параметра                                                                                                                       | :code:`"columns" => "id, name"`                                         |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------+
| bind        | Используется вместе с условием поиск, он заменяет указатели, освобождает значения для увеличения безопасности                                                                                                                                    | :code:`"bind" => ["status" => "A", "type" => "some-time"]`              |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------+
| bindTypes   | При использовании связующих указателей вы можете использовать этот параметр, для указания типа данных, что еще больше увеличит безопасность                                                                                                      | :code:`"bindTypes" => [Column::BIND_PARAM_STR, Column::BIND_PARAM_INT]` |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------+
| order       | Используется для сортировки результатов. Можно использовать несколько полей через запятую                                                                                                                                                        | :code:`"order" => "name DESC, status"`                                  |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------+
| limit       | Ограничивает результаты запроса                                                                                                                                                                                                                  | :code:`"limit" => 10`                                                   |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------+
| offset      | Offset the results of the query by a certain amount                                                                                                                                                                                              | :code:`"offset" => 5`                                                   |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------+
| group       | Позволяет собирать данные на несколько записей и групп результатов по одному или нескольким столбцам                                                                                                                                             | :code:`"group" => "name, status"`                                       |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------+
| for_update  | С этой опцией, :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` читает последние доступные данные, устанавливает исключительные блокировки на каждую прочтенную запись                                                                      | :code:`"for_update" => true`                                            |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------+
| shared_lock | С этой опцией, :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` читает последние доступные данные, устанавливает общие блокировки на каждую прочтенную запись                                                                               | :code:`"shared_lock" => true`                                           |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------+
| cache       | Кэширует результаты, уменьшая нагрузку на реляционную систему.                                                                                                                                                                                   | :code:`"cache" => ["lifetime" => 3600, "key" => "my-find-key"]`         |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------+
| hydration   | Устанавливает режим гидратации для представления каждой записи в результате                                                                                                                                                                      | :code:`"hydration" => Resultset::HYDRATE_OBJECTS`                       |
+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------+

Существует еще один вариант записи запросов поиска, в объектно-ориентированном стиле:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robots = Robots::query()
        ->where("type = :type:")
        ->andWhere("year < 2000")
        ->bind(["type" => "mechanical"])
        ->order("name")
        ->execute();

Статический метод :code:`query()` возвращает :doc:`Phalcon\\Mvc\\Model\\Criteria <../api/Phalcon_Mvc_Model_Criteria>` объект, который нормально работает с автокомплитом среды разработки.

Все запросы внутри обрабатываются как :doc:`PHQL <phql>` запросы. PHQL это высокоуровневый, объектно-ориентированный, SQL подобный язык.
Этот язык предоставляет вам больше возможностей для выполнения запросов, таких как объединение с другими моделями, определение группировок, добавление агрегации и т.д.

Наконец, имеется метод :code:`findFirstBy<название-свойства>()`. Данный метод расширяет упомянутый ранее :code:`findFirst()`. Он позволяет вам выполнять
поиск по таблице, используя название свойства в самом методе, и, передавая ему параметр, содержащий информацию по которой вы хотите произвести поиск в столбце.
В качестве примера возьмем упомянутую ранее модель Robots:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public $id;

        public $name;

        public $price;
    }

Мы имеем три свойства, с которыми можно работать: :code:`$id`, :code:`$name` и :code:`$price`. Допустим, вы хотите получить первую запись
с именем 'Terminator'. Можно сделать это следующим образом:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $name = "Terminator";

    $robot = Robots::findFirstByName($name);

    if ($robot) {
        echo "Первый робот с именем " . $name . " стоит " . $robot->price . ".";
    } else {
        echo "В нашей таблице не найдено роботов с именем " . $name . ".";
    }

Заметьте, что мы используем 'Name' в вызове метода, а также передаем ему переменную :code:`$name`, содержащую имя,
которое мы ищем в таблице. Также обратите внимание, что если по запросу была найдена запись, то и все остальные свойства
тоже доступны.

Возвращение результатов моделью
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
В то время как :code:`findFirst()` возвращает непосредственно экземпляр вызванного класса (когда это возвращаемые данные), метод :code:`find()` возвращает
:doc:`Phalcon\\Mvc\\Model\\Resultset\\Simple <../api/Phalcon_Mvc_Model_Resultset_Simple>`. Этот объект включает в себя весь функционал
такой как, обходы, поиск определенных записей, подсчет и прочее.

Эти объекты являются более мощными, чем стандартные массивы. Одной из важнейших особенностей :doc:`Phalcon\\Mvc\\Model\\Resultset <../api/Phalcon_Mvc_Model_Resultset>`
является то, что в любой момент времени в памяти содержится только одна запись. Это очень помогает в управлении памятью, особенно при работе с большими объемами данных.

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    // Получить всех роботов
    $robots = Robots::find();

    // Обход в foreach
    foreach ($robots as $robot) {
        echo $robot->name, "\n";
    }

    // Обход в while
    $robots->rewind();

    while ($robots->valid()) {
        $robot = $robots->current();

        echo $robot->name, "\n";

        $robots->next();
    }

    // Посчитать количество роботов
    echo count($robots);

    // Альтернативный способ посчитать количество записей
    echo $robots->count();

    // Перемещение внутреннего курсора к третьему роботу
    $robots->seek(2);

    $robot = $robots->current();

    // Получить робота по его позиции в наборе результатов
    $robot = $robots[5];

    // Проверка существования записи с соответствующим индексом
    if (isset($robots[3])) {
       $robot = $robots[3];
    }

    // Получить первую запись в наборе результатов
    $robot = $robots->getFirst();

    // Получить последнюю запись
    $robot = $robots->getLast();

Набор результатов в Phalcon эмулирует перемещаемый курсор, вы можете получить любую строку по её позиции, или установив внутренний указатель
в конкретную позицию. Обратите внимание, что некоторые системы баз данных не поддерживают курсоры с прокруткой, это заставляет базу данных повторно выполнять запрос
для того, чтобы перемотать курсор в начало и получить запись в запрашиваемой позиции. Аналогично, если набор результатов
вызывается несколько раз, то и запрос должен быть выполнен такое же количество раз.

Хранение больших результатов запроса в памяти может потребовать много ресурсов, из-за этого наборы результатов получаются
из базы данных блоками по 32 строки, снижая потребность в повторном выполнении запроса, в ряде случаев экономя память.

Обратите внимание, что наборы результатов могут быть сериализованы и храниться в кэше бэкэнда. :doc:`Phalcon\\Cache <cache>` может помочь с этой задачей. Тем не менее,
сериализация данных заставляет :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` получить все данные из базы данных в массив,
таким образом, в процессе потребляя больше памяти.

.. code-block:: php

    <?php

    // Запрос всех записей из модели Parts
    $parts = Parts::find();

    // Сериализуем  результат и сохраняем в файл
    file_put_contents(
        "cache.txt",
        serialize($parts)
    );

    // Достаём parts из файла
    $parts = unserialize(
        file_get_contents("cache.txt")
    );

    // Обходим parts в foreach
    foreach ($parts as $part) {
        echo $part->id;
    }

Фильтрация результатов
^^^^^^^^^^^^^^^^^^^^^^
Самый эффективный способ фильтрации данных - задание поисковых критериев. База данных сможет использовать индексирование, чтобы быстрее вернуть результат.
В дополнение, Phalcon позволяет вам производить фильтрацию данных с помощью PHP, расширяя тем самым возможности базы данных:

.. code-block:: php

    <?php

    $customers = Customers::find();

    $customers = $customers->filter(
        function ($customer) {
            // Вернуть клиентов только с корректным e-mail адресом
            if (filter_var($customer->email, FILTER_VALIDATE_EMAIL)) {
                return $customer;
            }
        }
    );

Привязка параметров
^^^^^^^^^^^^^^^^^^^
Привязка параметров также поддерживается в :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>`. Использование привязки параметров рекомендуется,
чтобы исключить возможность SQL инъекции.
Привязка параметров поддерживает строки и числа:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    // Запрос роботов с параметрами, привязанными к строковым заполнителям
    // Параметры с ключами, идентичными заполнителям
    $robots = Robots::find(
        [
            "name = :name: AND type = :type:",
            "bind" => [
                "name" => "Robotina",
                "type" => "maid",
            ],
        ]
    );

    // Запрос роботов с параметрами, привязанными к числовым заполнителям
    $robots = Robots::find(
        [
            "name = ?1 AND type = ?2",
            "bind" => [
                1 => "Robotina",
                2 => "maid",
            ],
        ]
    );

    // Запрос роботов с параметрами, привязанными к строковым и числовым заполнителям
    // Параметры с ключами, идентичными заполнителям
    $robots = Robots::find(
        [
            "name = :name: AND type = ?1",
            "bind" => [
                "name" => "Robotina",
                1      => "maid",
            ],
        ]
    );

При использовании цифровых указателей, необходимо определить их как целые числа, то есть 1 или 2. В этом случае "1" или "2" считаются строками,
а не числами, поэтому указатель не может быть успешно заменен.

Строки автоматически изолируются используя PDO_. Эта функция принимает во внимание кодировку соединения с базой данных, поэтому рекомендуется определять
корректную кодировку в параметрах соединения или в конфигурации базы данных, так как неправильная кодировка приведет
к некорректному хранению и извлечению данных.

Кроме того, вы можете установить параметр "bindTypes", что позволит определить, каким образом параметры должны быть связаны в соответствии с их типами данных:

.. code-block:: php

    <?php

    use Phalcon\Db\Column;
    use Store\Toys\Robots;

    // Привязка параметров
    $parameters = [
        "name" => "Robotina",
        "year" => 2008,
    ];

    // Привязка типов параметров
    $types = [
        "name" => Column::BIND_PARAM_STR,
        "year" => Column::BIND_PARAM_INT,
    ];

    // Запрос роботов с параметрами, привязанными к строковым заполнителям и типам
    $robots = Robots::find(
        [
            "name = :name: AND year = :year:",
            "bind"      => $parameters,
            "bindTypes" => $types,
        ]
    );

.. highlights::

    Поскольку тип связывания по умолчанию :code:`Phalcon\Db\Column::BIND_PARAM_STR`, нет необходимости указывать
    параметр "bindTypes", если все столбцы этого типа.

Если вы связываете массивы с параметрами, то помните, что нумерация ключей должна начинаться с нуля:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $array = ["a","b","c"]; // $array: [[0] => "a", [1] => "b", [2] => "c"]

    unset($array[1]); // $array: [[0] => "a", [2] => "c"]

    // Теперь необходимо перенумеровать ключи
    $array = array_values($array); // $array: [[0] => "a", [1] => "c"]

    $robots = Robots::find(
        [
            'letter IN ({letter:array})',
            'bind' => [
                'letter' => $array
            ]
        ]
    );

.. highlights::

    Привязка параметров доступна для всех запросов метода, таких как :code:`find()` и :code:`findFirst()`, а так же для
    методов :code:`count()`, :code:`sum()`, :code:`average()` и т.д.

Если вы используете "find" методы, то привязка параметров происходит автоматически:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    // Запрос с явной привязкой параметров
    $robots = Robots::find(
        [
            "name = ?0",
            "bind" => [
                "Ultron",
            ],
        ]
    );

    // Запрос с неявной привязкой параметров
    $robots = Robots::findByName("Ultron");

Инициализация/изменение полученных записей
------------------------------------------
Бывают случаи, что после получения записи из базы данных необходимо инициализировать данные перед
их использованием остальной частью приложения. Вы можете определить в модели метод :code:`afterFetch()`. Этот метод
будет выполнен сразу после создания экземпляра записи и получения им данных:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public $id;

        public $name;

        public $status;

        public function beforeSave()
        {
            // Преобразуем массив в строку
            $this->status = join(",", $this->status);
        }

        public function afterFetch()
        {
            // Преобразуем строку в массив
            $this->status = explode(",", $this->status);
        }
        
        public function afterSave()
        {
            // Преобразуем строку в массив
            $this->status = explode(",", $this->status);
        }
    }

Независимо от того, используете вы геттеры/сеттеры или публичные свойства, вы можете реализовать обработку поля
при получении доступа к последнему:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public $id;

        public $name;

        public $status;

        public function getStatus()
        {
            return explode(",", $this->status);
        }
    }

Отношения между моделями
------------------------
Существует четыре типа отношений: один-к-одному, один-ко-многим, многие-к-одному и многие-ко-многим. Отношения могут быть
однонаправленными или двунаправленными, и каждое может быть простым (один модель к одной) или более сложные (комбинация моделей).
Менеджер моделей управляет ограничением внешних ключей для этих отношений, их определение помогает ссылочной целостности,
а также обеспечивает легкий и быстрый доступ к соответствующей записи в модели. Благодаря реализации отношений,
легко получить доступ к данным в связных моделях для любой выбранной записи(-ей).

Однонаправленные отношения
^^^^^^^^^^^^^^^^^^^^^^^^^^
Однонаправленные отношения это те отношения, которые генерируются в отношении от одной к другой, но не наоборот.

Двунаправленные отношения
^^^^^^^^^^^^^^^^^^^^^^^^^
Двунаправленные отношения создают отношения в обеих моделях, и каждая модель определяет обратную связь от другой.

Определение отношений
^^^^^^^^^^^^^^^^^^^^^
В Phalcon отношения должны быть определены в методе :code:`initialize()` модели. Методы :code:`belongsTo()`, :code:`hasOne()`,
:code:`hasMany()` и :code:`hasManyToMany()` определяют отношения между одним или несколькими полями из текущей модели в поля
другой модели. Каждый из этих методов требует 3 параметра: поля текущей модели, модель, на которую ссылаются, и ее поля.

+---------------+--------------------------+
| Метод         | Описание                 |
+===============+==========================+
| hasMany       | Определяет 1-n отношения |
+---------------+--------------------------+
| hasOne        | Определяет 1-1 отношения |
+---------------+--------------------------+
| belongsTo     | Определяет n-1 отношения |
+---------------+--------------------------+
| hasManyToMany | Определяет n-n отношения |
+---------------+--------------------------+

Следующая схема показывает 3 таблицы, чьи отношения будут служить нам в качестве примера, касающиеся отношений:

.. code-block:: sql

    CREATE TABLE `robots` (
        `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
        `name` varchar(70) NOT NULL,
        `type` varchar(32) NOT NULL,
        `year` int(11) NOT NULL,
        PRIMARY KEY (`id`)
    );

    CREATE TABLE `robots_parts` (
        `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
        `robots_id` int(10) NOT NULL,
        `parts_id` int(10) NOT NULL,
        `created_at` DATE NOT NULL,
        PRIMARY KEY (`id`),
        KEY `robots_id` (`robots_id`),
        KEY `parts_id` (`parts_id`)
    );

    CREATE TABLE `parts` (
        `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
        `name` varchar(70) NOT NULL,
        PRIMARY KEY (`id`)
    );

* Модель "Robots" имеет несколько "RobotsParts".
* Модель "Parts" имеет несколько "RobotsParts".
* Модель "RobotsParts" принадлежит обоим "Robots" и "Parts" моделям как многие-к-одному.
* Модель "Robots" имеет отношение многие-ко-многим к "Parts" через "RobotsParts".

Посмотрим EER схему, чтобы лучше понять отношения:

.. figure:: ../_static/img/eer-1.png
    :align: center

Модели с их отношениями могут быть реализованы следующим образом:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public $id;

        public $name;

        public function initialize()
        {
            $this->hasMany(
                "id",
                "RobotsParts",
                "robots_id"
            );
        }
    }

.. code-block:: php

    <?php

    use Phalcon\Mvc\Model;

    class Parts extends Model
    {
        public $id;

        public $name;

        public function initialize()
        {
            $this->hasMany(
                "id",
                "RobotsParts",
                "parts_id"
            );
        }
    }

.. code-block:: php

    <?php

    use Phalcon\Mvc\Model;

    class RobotsParts extends Model
    {
        public $id;

        public $robots_id;

        public $parts_id;

        public function initialize()
        {
            $this->belongsTo(
                "robots_id",
                "Store\\Toys\\Robots",
                "id"
            );

            $this->belongsTo(
                "parts_id",
                "Parts",
                "id"
            );
        }
    }

Первый параметр указывает локальные поля модели, используемые в отношениях; второй указывает имя
модели, на которую ссылаются; и третий - имя поля в указанной модели. Вы также можете использовать массивы для определения нескольких полей в отношениях.

Отношение "многие-ко-многим" требуют 3 модели и определение атрибутов, участвующих в отношениях:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public $id;

        public $name;

        public function initialize()
        {
            $this->hasManyToMany(
                "id",
                "RobotsParts",
                "robots_id", "parts_id",
                "Parts",
                "id"
            );
        }
    }

Преимущества отношений
^^^^^^^^^^^^^^^^^^^^^^
При явном определении отношений между моделями, легко найти относящиеся записи для конкретной записи.

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = Robots::findFirst(2);

    foreach ($robot->robotsParts as $robotPart) {
        echo $robotPart->parts->name, "\n";
    }

Phalcon использует магические методы :code:`__set`/:code:`__get`/:code:`__call` для сохранения или извлечения связанных данных, используя отношения.

По доступу к атрибуту с таким же именем, что и отношения, будем получать все связанные с ней записи.

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = Robots::findFirst();

    // все связанные записи в RobotsParts
    $robotsParts = $robot->robotsParts;

Кроме того, вы можете использовать магические геттеры:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = Robots::findFirst();

    // все связанные записи в RobotsParts
    $robotsParts = $robot->getRobotsParts();

    // передача параметров
    $robotsParts = $robot->getRobotsParts(
        [
            "limit" => 5,
        ]
    );

Если вызываемый метод имеет "get" префикс, то :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` вернет
:code:`findFirst()`/:code:`find()`. В следующем примере сравниваются получение соответствующих результатов с использованием магических методов
и без:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = Robots::findFirst(2);

    // Модель Robots имеет отношение 1-n (hasMany)
    // к RobotsParts
    $robotsParts = $robot->robotsParts;

    // Только те, которые соответствуют условию
    $robotsParts = $robot->getRobotsParts("created_at = '2015-03-15'");

    // Или используя связанные параметры
    $robotsParts = $robot->getRobotsParts(
        [
            "created_at = :date:",
            "bind" => [
                "date" => "2015-03-15"
            ]
        ]
    );

    $robotPart = RobotsParts::findFirst(1);

    // Модель RobotsParts имеет отношение n-1 (belongsTo)
    // к Robots
    $robot = $robotPart->robots;

Получение связанных записей вручную:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = Robots::findFirst(2);

    // Модель Robots имеет отношение 1-n (hasMany)
    // к  RobotsParts
    $robotsParts = RobotsParts::find(
        "robots_id = '" . $robot->id . "'"
    );

    // Только те, которые соответствуют условиям
    $robotsParts = RobotsParts::find(
        "robots_id = '" . $robot->id . "' AND created_at = '2015-03-15'"
    );

    $robotPart = RobotsParts::findFirst(1);

    // Модель RobotsParts имеет отношение n-1 (belongsTo)
    // к RobotsParts
    $robot = Robots::findFirst(
        "id = '" . $robotPart->robots_id . "'"
    );


Префикс "get" используется для поиска связанных записей. В зависимости от типа отношений будет использоваться
:code:`find()` или :code:`findFirst()`:

+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+
| Тип                | Описание                                                                                                                                               | Неявный метод       |
+====================+========================================================================================================================================================+=====================+
| Belongs-To         | Возвращает экземпляр модели взаимосвязанной записи                                                                                                     | findFirst           |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+
| Has-One            | Возвращает экземпляр модели взаимосвязанной записи                                                                                                     | findFirst           |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+
| Has-Many           | Возвращает коллекцию экземпляров модели, на которую ссылается данная модель                                                                            | find                |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+
| Has-Many-to-Many   | Возвращает коллекцию экземпляров модели, на которую ссылается данная модель, неявно выполняются внутренние соединения (inner join) с зависимой моделью | составной запрос    |
+--------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+

Вы можете также использовать префикс "count" для подсчета количества связанных записей:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = Robots::findFirst(2);

    echo "У робота ", $robot->countRobotsParts(), " частей\n";

Алиасы отношений
^^^^^^^^^^^^^^^^
Чтобы лучше объяснить, как алиасы работают, давайте рассмотрим следующий пример:

В таблице "robots_similar" есть функция, для определения, что роботы похожи на других:

.. code-block:: bash

    mysql> desc robots_similar;
    +-------------------+------------------+------+-----+---------+----------------+
    | Field             | Type             | Null | Key | Default | Extra          |
    +-------------------+------------------+------+-----+---------+----------------+
    | id                | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
    | robots_id         | int(10) unsigned | NO   | MUL | NULL    |                |
    | similar_robots_id | int(10) unsigned | NO   |     | NULL    |                |
    +-------------------+------------------+------+-----+---------+----------------+
    3 rows in set (0.00 sec)

И "robots_id" и "similar_robots_id" имеют отношение к модели Robots:

.. figure:: ../_static/img/eer-2.png
   :align: center

Модель, которая отображает эту таблицу и ее отношения выглядит так:

.. code-block:: php

    <?php

    class RobotsSimilar extends Phalcon\Mvc\Model
    {
        public function initialize()
        {
            $this->belongsTo(
                "robots_id",
                "Store\\Toys\\Robots",
                "id"
            );

            $this->belongsTo(
                "similar_robots_id",
                "Store\\Toys\\Robots",
                "id"
            );
        }
    }

Так как отношения указывают на ту же модель (Robots), получить записи, относящиеся к взаимосвязи корректно нельзя:

.. code-block:: php

    <?php

    $robotsSimilar = RobotsSimilar::findFirst();

    // Возвращает связанную запись на основе столбца (robots_id)
    // Потому как имеется отношение belongsTo, то возвращается только одна запись,
    // но название 'getRobots' подразумевает, что вернётся больше одной записи
    $robot = $robotsSimilar->getRobots();

    // но, как получить соответствующую запись на основании столбца (similar_robots_id)
    // если оба отношения имеют одно и то же имя?

Алиасы позволяют переименовать оба отношения для решения этих проблем:

.. code-block:: php

    <?php

    use Phalcon\Mvc\Model;

    class RobotsSimilar extends Model
    {
        public function initialize()
        {
            $this->belongsTo(
                "robots_id",
                "Store\\Toys\\Robots",
                "id",
                [
                    "alias" => "Robot",
                ]
            );

            $this->belongsTo(
                "similar_robots_id",
                "Store\\Toys\\Robots",
                "id",
                [
                    "alias" => "SimilarRobot",
                ]
            );
        }
    }

С алиасами мы можем легко получить соответствующие записи:

.. code-block:: php

    <?php

    $robotsSimilar = RobotsSimilar::findFirst();

    // Возвращает связанную запись на основе столбца (robots_id)
    $robot = $robotsSimilar->getRobot();
    $robot = $robotsSimilar->robot;

    // Возвращает связанную запись на основе столбца (similar_robots_id)
    $similarRobot = $robotsSimilar->getSimilarRobot();
    $similarRobot = $robotsSimilar->similarRobot;

Магические методы против явных
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Большинство сред IDE и редакторов с автодополнением не могут определить корректные типы при использовании магических методов,
вместо этого вы можете при желании задать эти методы явно с соответствующими
doc-блоками, помогая IDE лучше выполнять автодополнение:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public $id;

        public $name;

        public function initialize()
        {
            $this->hasMany(
                "id",
                "RobotsParts",
                "robots_id"
            );
        }

        /**
         * Возвращает соответствующие "robots parts"
         *
         * @return \RobotsParts[]
         */
        public function getRobotsParts($parameters = null)
        {
            return $this->getRelated("RobotsParts", $parameters);
        }
    }

Виртуальные внешние ключи
-------------------------
По умолчанию отношения не ведут себя как внешние ключи базы данных, то есть, если вы пытаетесь вставить/обновить значение, не имея действительного
значения в модели, на которую ссылаетесь, то Phalcon не выведет никаких сообщений валидации. Вы можете изменить данное поведение, добавив четвертый параметр
при определении отношения.

Модель RobotsPart может быть изменена, чтобы продемонстрировать эту функцию:

.. code-block:: php

    <?php

    use Phalcon\Mvc\Model;

    class RobotsParts extends Model
    {
        public $id;

        public $robots_id;

        public $parts_id;

        public function initialize()
        {
            $this->belongsTo(
                "robots_id",
                "Store\\Toys\\Robots",
                "id",
                [
                    "foreignKey" => true
                ]
            );

            $this->belongsTo(
                "parts_id",
                "Parts",
                "id",
                [
                    "foreignKey" => [
                        "message" => "part_id не существует в модели Parts"
                    ]
                ]
            );
        }
    }

Если вы изменяете отношение :code:`belongsTo()`, включая foreignKey, то значения, вставленные/обновленные в тех полях, будут проверяться
на корректность. Аналогичным образом, если изменяется :code:`hasMany()`/:code:`hasOne()`, будет проверяться, то что записи не могут быть удалены,
если используются в зависимой модели.

.. code-block:: php

    <?php

    use Phalcon\Mvc\Model;

    class Parts extends Model
    {
        public function initialize()
        {
            $this->hasMany(
                "id",
                "RobotsParts",
                "parts_id",
                [
                    "foreignKey" => [
                        "message" => "Деталь не может быть удалена, поскольку другие роботы используют ее",
                    ]
                ]
            );
        }
    }

Виртуальный внешний ключ может быть установлен, чтобы позволить работать с :code:`null` значениями:

.. code-block:: php

    <?php

    use Phalcon\Mvc\Model;

    class RobotsParts extends Model
    {
        public $id;

        public $robots_id;

        public $parts_id;

        public function initialize()
        {
            $this->belongsTo(
                "parts_id",
                "Parts",
                "id",
                [
                    "foreignKey" => [
                        "allowNulls" => true,
                        "message"    => "part_id нет в модели Parts",
                    ]
                ]
            );
        }
    }

Cascade/restrict действия
^^^^^^^^^^^^^^^^^^^^^^^^^
Отношения, которые задействуют виртуальные внешние ключи, по умолчанию ограничивают создание/обновление/удаление записей
для поддержания целостности данных:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;
    use Phalcon\Mvc\Model\Relation;

    class Robots extends Model
    {
        public $id;

        public $name;

        public function initialize()
        {
            $this->hasMany(
                "id",
                "Parts",
                "robots_id",
                [
                    "foreignKey" => [
                        "action" => Relation::ACTION_CASCADE,
                    ]
                ]
            );
        }
    }

Код выше удалит все относящиеся записи (parts), если основная запись (robot) удаляется.

Использование расчетов
----------------------
Расчеты являются помощниками для часто используемых функций СУБД, таких как COUNT, SUM, MAX, MIN или AVG.
:doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` позволяет использовать эти функции непосредственно с доступными методами.

Пример подсчета:

.. code-block:: php

    <?php

    // Сколько сотрудников работает?
    $rowcount = Employees::count();

    // Сколько уникальных сфер деятельности рабочих?
    $rowcount = Employees::count(
        [
            "distinct" => "area",
        ]
    );

    // Сколько сотрудников работает в сфере тестирования?
    $rowcount = Employees::count(
        "area = 'Testing'"
    );

    // Посчитать сотрудников, сгруппировав результаты по сфере деятельности
    $group = Employees::count(
        [
            "group" => "area",
        ]
    );
    foreach ($group as $row) {
       echo $row->rowcount, " сотрудников в ", $row->area;
    }

    // Посчитать сотрудников, сгруппировав результаты по сфере деятельности, и упорядочив их по количеству
    $group = Employees::count(
        [
            "group" => "area",
            "order" => "rowcount",
        ]
    );

    // Избегайте SQL инъекции, используя связанные параметры
    $group = Employees::count(
        [
            "type > ?0",
            "bind" => [
                $type
            ],
        ]
    );

Пример суммы:

.. code-block:: php

    <?php

    // Какая заработная плата всех сотрудников?
    $total = Employees::sum(
        [
            "column" => "salary",
        ]
    );

    // Какая заработная плата всех сотруднииков в сфере продаж?
    $total = Employees::sum(
        [
            "column"     => "salary",
            "conditions" => "area = 'Sales'",
        ]
    );

    // Группирует заработные платы по каждой сфере деятельности
    $group = Employees::sum(
        [
            "column" => "salary",
            "group"  => "area",
        ]
    );
    foreach ($group as $row) {
       echo "Сумма заработной платы ", $row->area, " составляет ", $row->sumatory;
    }

    // Группирует заработные платы по каждой сферы деятельности
    // и упорядочивает их от большего к меньшему
    $group = Employees::sum(
        [
            "column" => "salary",
            "group"  => "area",
            "order"  => "sumatory DESC",
        ]
    );

    // Избегайте SQL инъекции, используя связанные параметры
    $group = Employees::sum(
        [
            "conditions" => "area > ?0",
            "bind"       => [
                $area
            ],
        ]
    );

Пример поиска среднего:

.. code-block:: php

    <?php

    // Какая средняя зарплата среди всех сотрудников?
    $average = Employees::average(
        [
            "column" => "salary",
        ]
    );

    // Какая средняя зарплата среди сотрудников сферы продаж?
    $average = Employees::average(
        [
            "column"     => "salary",
            "conditions" => "area = 'Sales'",
        ]
    );

    // Избегайте SQL инъекции, используя связанные параметры
    $average = Employees::average(
        [
            "column"     => "age",
            "conditions" => "area > ?0",
            "bind"       => [
                $area
            ],
        ]
    );

Пример нахождения максимального/минимального:

.. code-block:: php

    <?php

    // Какой максимальный возраст среди всех сотрудников?
    $age = Employees::maximum(
        [
            "column" => "age",
        ]
    );

    // Какой максимальный возраст среди сотрудников сферы продаж?
    $age = Employees::maximum(
        [
            "column"     => "age",
            "conditions" => "area = 'Sales'",
        ]
    );

    // Какая минимальная зарплата среди сотрудников?
    $salary = Employees::minimum(
        [
            "column" => "salary",
        ]
    );

Режимы гидрации
---------------
Как упоминалось выше, наборы результатов (resultsets) являются коллекцией конечных объектов, это означает, что каждый возвращенный результат является объектом,
представляющим собой строку в базе данных. Эти объекты могут быть изменены и сохранены снова:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robots = Robots::find();

    // Изменение и сохранение полученных обектов модели роботов
    foreach ($robots as $robot) {
        $robot->year = 2000;

        $robot->save();
    }

Иногда записи могут быть представлены пользователю в режиме только для чтения, в таких случаях может быть полезно
изменить способ представления записей, для облегчения их обработки. Способ, используемый для представления объектов,
возвращаемых в наборе результатов называется 'режим гидрации':

.. code-block:: php

    <?php

    use Phalcon\Mvc\Model\Resultset;
    use Store\Toys\Robots;

    $robots = Robots::find();

    // Вернёт каждого робота в виде массива
    $robots->setHydrateMode(
        Resultset::HYDRATE_ARRAYS
    );

    foreach ($robots as $robot) {
        echo $robot["year"], PHP_EOL;
    }

    // Вернёт каждого робота в stdClass
    $robots->setHydrateMode(
        Resultset::HYDRATE_OBJECTS
    );

    foreach ($robots as $robot) {
        echo $robot->year, PHP_EOL;
    }

    // Вернёт каждого робота как экземпляр класса Robots
    $robots->setHydrateMode(
        Resultset::HYDRATE_RECORDS
    );

    foreach ($robots as $robot) {
        echo $robot->year, PHP_EOL;
    }

Режим гидрации также может быть передан в качестве параметра в 'find':

.. code-block:: php

    <?php

    use Phalcon\Mvc\Model\Resultset;
    use Store\Toys\Robots;

    $robots = Robots::find(
        [
            "hydration" => Resultset::HYDRATE_ARRAYS,
        ]
    );

    foreach ($robots as $robot) {
        echo $robot["year"], PHP_EOL;
    }

Создание/обновление записей
---------------------------
Метод :code:`Phalcon\Mvc\Model::save()` позволяет создавать/обновлять записи в зависимости от того, существуют ли они уже в таблице,
связанной с моделью. Метод save вызывается методами create и update класса :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>`.
Для этого необходимо иметь в таблице должным образом установленный первичный ключ, чтобы можно было определить, должна ли запись
быть обновлена или создана.

Также метод выполняет связанные валидаторы, виртуальные внешние ключи и события, которые определены в модели:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = new Robots();

    $robot->type = "mechanical";
    $robot->name = "Astro Boy";
    $robot->year = 1952;

    if ($robot->save() === false) {
        echo "Мы не можем сохранить робота прямо сейчас: \n";

        $messages = $robot->getMessages();

        foreach ($messages as $message) {
            echo $message, "\n";
        }
    } else {
        echo "Отлично, новый робот был успешно сохранен!";
    }

В метод “save” может быть передан массив, чтобы избежать назначения каждого столбца вручную. :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` проверит, есть ли сеттеры, реализованные для
столбцов, для значений переданных в массиве, отдавая приоритет им, вместо непосредственно назначения значений свойствам:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = new Robots();

    $robot->save(
        [
            "type" => "mechanical",
            "name" => "Astro Boy",
            "year" => 1952,
        ]
    );

Значения, назначеные непосредственно через атрибуты или через массив, экранируются/проверяются в соответствии с типом данных атрибута. Таким образом, вы можете передать
ненадежный массив, не беспокоясь о возможных SQL инъекциях:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = new Robots();

    $robot->save($_POST);

.. highlights::

    Без каких-либо мер предосторожности передача массива в данный метод позволит злоумышленникам установить значение любого столбца базы данных. Используйте эту возможность только в том случае,
    если вы хотите позволить пользователю добавлять/обновлять каждый столбец в модели, даже если этих полей нет в отправленной
    форме.

Вы можете передать дополнительный параметр в метод 'save', чтобы установить список полей, которые должны быть прининяты во внимание при
массовом присваивании:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = new Robots();

    $robot->save(
        $_POST,
        [
            "name",
            "type",
        ]
    );

Создание/обновление с уверенностью
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
При разработке мы можем столкнуться с ситуацией, когда две идентичные записи происходят одновременно. Это
может произойти, если мы используем :code:`Phalcon\Mvc\Model::save()` для сохранения элемента в БД. Если мы хотим быть абсолютно
уверены, что запись будет создана или обновлена, мы можем заменить :code:`save()` на вызов :code:`create()` или :code:`update()`:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = new Robots();

    $robot->type = "mechanical";
    $robot->name = "Astro Boy";
    $robot->year = 1952;

    // Эта запись только должна быть создана
    if ($robot->create() === false) {
        echo "Мы не можем сохранить робота прямо сейчас: \n";

        $messages = $robot->getMessages();

        foreach ($messages as $message) {
            echo $message, "\n";
        }
    } else {
        echo "Отлично, новый робот был успешно создан!";
    }

Методы "create" и "update" также принимают массив значений в качестве параметра.

Автоматически генерируемый столбец идентификаторов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Некоторые модели могут иметь столбцы идентификаторов. Эти столбцы, обычно, являются первичными ключами таблицы. :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>`
может распознать столбец идентификаторов, исключая его из сгенерированного SQL INSERT, так как СУБД может генерировать значение для него автоматически.
Всегда после создания записи в поле идентификатора будет установлено значение, сгенерированое в СУБД:

.. code-block:: php

    <?php

    $robot->save();

    echo "Сгенерированный идентификатор: ", $robot->id;

:doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` может распознать столбец идентификаторов. В зависимости от системы баз данных, это могут быть столбцы
serial, как в PostgreSQL, или auto_increment, в случае MySQL.

PostgreSQL использует последовательности для создания автонумерации значений, Phalcon пытается получить сгенерированное значение из последовательности "table_field_seq",
например: robots_id_seq, если эта последовательность имеет другое имя, то должен быть реализован метод :code:`getSequenceName()`:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public function getSequenceName()
        {
            return "robots_sequence_name";
        }
    }

Связаное сохранение записей
^^^^^^^^^^^^^^^^^^^^^^^^^^^
Магические свойства могут быть использованы для хранения записей и связанных с ними свойств:

.. code-block:: php

    <?php

    // Создать артиста
    $artist = new Artists();

    $artist->name    = "Shinichi Osawa";
    $artist->country = "Japan";

    // Создать альбом
    $album = new Albums();

    $album->name   = "The One";
    $album->artist = $artist; // Назначить артиста
    $album->year   = 2008;

    // Сохранить обе записи
    $album->save();

Сохранение записи и связанных с ней записей в has-many соотношении:

.. code-block:: php

    <?php

    // Получить существующего артиста
    $artist = Artists::findFirst(
        "name = 'Shinichi Osawa'"
    );

    // Создать альбом
    $album = new Albums();

    $album->name   = "The One";
    $album->artist = $artist;

    $songs = [];

    // Создать первую песню
    $songs[0]           = new Songs();
    $songs[0]->name     = "Star Guitar";
    $songs[0]->duration = "5:54";

    // Создать вторую песню
    $songs[1]           = new Songs();
    $songs[1]->name     = "Last Days";
    $songs[1]->duration = "4:29";

    // Связать массив песен
    $album->songs = $songs;

    // Сохранить альбом + эти песни
    $album->save();

При сохранении альбома и группы неявно используются транзакции, так что если что-то
пойдет не так с сохранением соответствующих записей, то родитель не будет сохранен. Пользователю
будут переданы собщения с информацией об ошибках.

Обратите внимание: добавление связанных записей с помощью перегрузки следующих методов невозможно:

 - :code:`Phalcon\Mvc\Model::beforeSave()`
 - :code:`Phalcon\Mvc\Model::beforeCreate()`
 - :code:`Phalcon\Mvc\Model::beforeUpdate()`

Для этого вам необходимо перегрузить метод :code:`Phalcon\Mvc\Model::save()`.

Собщения об ошибках
^^^^^^^^^^^^^^^^^^^
:doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` имеет подсистему обмена сообщениями, которая обеспечивает гибкий способ генерации или хранения
сообщений об ошибках, сгенерированных во время создания/обновления записей.

Каждое сообщение состоит из экземпляра класса :doc:`Phalcon\\Mvc\\Model\\Message <../api/Phalcon_Mvc_Model_Message>` и набор
генерируемых сообщений может быть получен с помощью метода :code:`getMessages()`. Каждое сообщение содержит расширенную информацию, такую как
имя поля генерируемого сообщение или тип сообщения:

.. code-block:: php

    <?php

    if ($robot->save() === false) {
        $messages = $robot->getMessages();

        foreach ($messages as $message) {
            echo "Message: ", $message->getMessage();
            echo "Field: ", $message->getField();
            echo "Type: ", $message->getType();
        }
    }

:doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` может генерировать следующие типы сообщений:

+----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+
| Тип                  | Описание                                                                                                                                         |
+======================+==================================================================================================================================================+
| PresenceOf           | Генерируется, когда поле с атрибутом non-null в базе данных пытается вставить/обновить null значение                                             |
+----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+
| ConstraintViolation  | Генерируется, когда поле, являющееся частью виртуального внешнего ключа, пытается вставить/обновить значение, не существующее в указанной модели |
+----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+
| InvalidValue         | Генерируется, когда валидация не удалась из-за недопустимого значения                                                                            |
+----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+
| InvalidCreateAttempt | Генерируется, когда была предпринята попытка создать запись, которая уже существует                                                              |
+----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+
| InvalidUpdateAttempt | Генерируется, когда была предпринята попытка обновить запись, которая еще не существует                                                          |
+----------------------+--------------------------------------------------------------------------------------------------------------------------------------------------+

Метод :code:`getMessages()` может быть переопределен в модели, чтобы заменить/перевести сообщения по умолчанию, автоматически генерируемые ORM:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public function getMessages()
        {
            $messages = [];

            foreach (parent::getMessages() as $message) {
                switch ($message->getType()) {
                    case "InvalidCreateAttempt":
                        $messages[] = "Запись не может быть создана, потому что она уже существует";
                        break;

                    case "InvalidUpdateAttempt":
                        $messages[] = "Запись не может быть обновлена, потому что она еще не существует";
                        break;

                    case "PresenceOf":
                        $messages[] = "Поле " . $message->getField() . " является обязательным";
                        break;
                }
            }

            return $messages;
        }
    }

События и управление событиями
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Модели позволяют реализовать события, которые будут срабатывать при выполнении вставки/обновления/удаления. Они помогают определить бизнес-логику для
определенной модели. Ниже приведены события, поддерживаемые :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` и порядок их выполнения:

+--------------------+--------------------------+----------------------------+-----------------------------------------------------------------------------------------------------------------------+
| Операция           | Название                 | Можно остановить операцию? | Пояснение                                                                                                             |
+====================+==========================+============================+=======================================================================================================================+
| Вставка/обновление | beforeValidation         | ДА                         | Выполняется до проверки поля на не нулевую/пустую строку или на внешние ключи                                         |
+--------------------+--------------------------+----------------------------+-----------------------------------------------------------------------------------------------------------------------+
| Вставка            | beforeValidationOnCreate | ДА                         | Выполняется до проверки поля на не нулевую/пустую строку или на внешние ключи при выполнении операции вставки         |
+--------------------+--------------------------+----------------------------+-----------------------------------------------------------------------------------------------------------------------+
| Обновление         | beforeValidationOnUpdate | ДА                         | Выполняется до проверки поля на не нулевую/пустую строку или на внешние ключи при выполнении операции обновления      |
+--------------------+--------------------------+----------------------------+-----------------------------------------------------------------------------------------------------------------------+
| Вставка/обновление | onValidationFails        | ДА (уже остановлена)       | Выполняется после обнаружения нарушения целостности                                                                   |
+--------------------+--------------------------+----------------------------+-----------------------------------------------------------------------------------------------------------------------+
| Вставка            | afterValidationOnCreate  | ДА                         | Выполняется после проверки поля на не нулевую/пустую строку или на внешние ключи при выполнении операции вставки      |
+--------------------+--------------------------+----------------------------+-----------------------------------------------------------------------------------------------------------------------+
| Обновление         | afterValidationOnUpdate  | ДА                         | Выполняется после проверки поля на не нулевую/пустую строку или на внешние ключи при выполнении операции обновления   |
+--------------------+--------------------------+----------------------------+-----------------------------------------------------------------------------------------------------------------------+
| Вставка/обновление | afterValidation          | ДА                         | Выполняется после проверки поля на не нулевую/пустую строку или на внешние ключи                                      |
+--------------------+--------------------------+----------------------------+-----------------------------------------------------------------------------------------------------------------------+
| Вставка/обновление | beforeSave               | ДА                         | Выполняется до требуемой операции над системой базы данных                                                            |
+--------------------+--------------------------+----------------------------+-----------------------------------------------------------------------------------------------------------------------+
| Обновление         | beforeUpdate             | ДА                         | Выполняется до требуемой операции над системой базы данных для операции обновления                                    |
+--------------------+--------------------------+----------------------------+-----------------------------------------------------------------------------------------------------------------------+
| Вставка            | beforeCreate             | ДА                         | Выполняется до требуемой операции над системой базы данных для операции вставки                                       |
+--------------------+--------------------------+----------------------------+-----------------------------------------------------------------------------------------------------------------------+
| Обновление         | afterUpdate              | НЕТ                        | Выполняется после требуемой операции над системой базы данных для операции обновления                                 |
+--------------------+--------------------------+----------------------------+-----------------------------------------------------------------------------------------------------------------------+
| Вставка            | afterCreate              | НЕТ                        | Выполняется после требуемой операции над системой базы данных для операции вставки                                    |
+--------------------+--------------------------+----------------------------+-----------------------------------------------------------------------------------------------------------------------+
| Вставка/обновление | afterSave                | НЕТ                        | Выполняется после требуемой операции над системой базы данных                                                         |
+--------------------+--------------------------+----------------------------+-----------------------------------------------------------------------------------------------------------------------+

Реализация событий в классе модели
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Простой способ заставить модель реагировать на события - это реализовать метод с тем же именем события в классе модели:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public function beforeValidationOnCreate()
        {
            echo "Это выполняется перед созданием робота!";
        }
    }

События могут быть полезны для присвоения значений перед выполнением операции, например:

.. code-block:: php

    <?php

    use Phalcon\Mvc\Model;

    class Products extends Model
    {
        public function beforeCreate()
        {
            // Установить дату создания
            $this->created_at = date("Y-m-d H:i:s");
        }

        public function beforeUpdate()
        {
            // Установить дату модификации
            $this->modified_in = date("Y-m-d H:i:s");
        }
    }

Использование пользовательского менеджера событий
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Кроме того, этот компонент интегрируется с :doc:`Phalcon\\Events\\Manager <../api/Phalcon_Events_Manager>`,
это означает, что мы можем создать слушателей, которые запускаются при срабатывании события.

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;
    use Phalcon\Events\Event;
    use Phalcon\Events\Manager as EventsManager;

    class Robots extends Model
    {
        public function initialize()
        {
            $eventsManager = new EventsManager();

            // Добавляем анонимную функцию в качестве слушателя для событий "model"
            $eventsManager->attach(
                "model:beforeSave",
                function (Event $event, $robot) {
                    if ($robot->name == "Scooby Doo") {
                        echo "Scooby Doo isn't a robot!";

                        return false;
                    }

                    return true;
                }
            );

            // Устанавливаем менеджер событий для события
            $this->setEventsManager($eventsManager);
        }
    }

В примере, приведенном выше, менеджер событий действует только в качестве моста между объектом и слушателем (анонимной функцией).
События сработают сразу при сохренении "robots":

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = new Robots();

    $robot->name = "Scooby Doo";
    $robot->year = 1969;

    $robot->save();

Если мы хотим, чтобы все объекты, созданные в нашем приложении использовали один и тот же EventsManager, то мы должны назначить его менеджеру модели:

.. code-block:: php

    <?php

    use Phalcon\Events\Event;
    use Phalcon\Events\Manager as EventsManager;

    // Регистрация сервиса modelsManager
    $di->setShared(
        "modelsManager",
        function () {
            $eventsManager = new EventsManager();

            // Добавляем анонимную функцию в качестве слушателя для событий "model"
            $eventsManager->attach(
                "model:beforeSave",
                function (Event $event, $model) {
                    // Перехватываем события, производимые моделью Robots
                    if (get_class($model) === "Store\\Toys\\Robots") {
                        if ($model->name === "Scooby Doo") {
                            echo "Scooby Doo не робот!";

                            return false;
                        }
                    }

                    return true;
                }
            );

            // Устанавливаем EventsManager по умолчанию
            $modelsManager = new ModelsManager();

            $modelsManager->setEventsManager($eventsManager);

            return $modelsManager;
        }
    );

Если слушатель возвращает false, то это прерывает выполняемую операцию.

Реализация бизнес-логики
^^^^^^^^^^^^^^^^^^^^^^^^
При выполнении вставки, обновлении или удалении, модель проверяет, имеются ли методы, названия которых совпадают с названиями
событий, перечисленных в таблице выше.

Мы рекомендуем объявлять методы проверки как protected, чтобы эта часть бизнес-логики
не была доступна напрямую.

Следующий пример реализует событие, которое проверяет, что год не может быть меньше 0 при обновлении или вставке:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public function beforeSave()
        {
            if ($this->year < 0) {
                echo "Год не может быть меньше нуля!";

                return false;
            }
        }
    }

Некоторые события возвращают false как указание, что надо прервать текущую операцию. Если событие ничего не возвращает, то :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>`
предполагает, что было возвращено значение true.

Проверка целостности данных
^^^^^^^^^^^^^^^^^^^^^^^^^^^
:doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` предоставляет некоторые события для проверки данных и реализации бизнес-логики. Специальное событие "validation"
позволяет нам вызывать встроенные валидаторы для проверки записи. Phalcon имеет несколько встроенных валидаторов, которые можно использовать на этой стадии.

Следующий пример показывает, как это можно использовать:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;
    use Phalcon\Validation;
    use Phalcon\Validation\Validator\Uniqueness;
    use Phalcon\Validation\Validator\InclusionIn;

    class Robots extends Model
    {
        public function validation()
        {
            $validator = new Validation();

            $validator->validate(
                "type",
                new InclusionIn(
                    [
                        "domain" => [
                            "Mechanical",
                            "Virtual",
                        ]
                    ]
                )
            );

            $validator->validate(
                "name",
                new Uniqueness(
                    [
                        "message" => "Название робота должно быть уникальным",
                    ]
                )
            );

            return $this->validate($validator);
        }
    }

Приведенный выше пример выполняет проверку с помощью встроенного валидатора "InclusionIn". Он проверяет значение поля "type" в списке "domain". Если
значение отсутствует в методе, то валидация будет прервана и будет возвращено значение false. Доступны следующие валидаторы:

.. highlights::

    For more information on validators, see the :doc:`Validation documentation <validation>`.

Идея создания валидаторов заключается в их повторном использовании несколькими моделями. Валидатор может быть и простым, например:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;
    use Phalcon\Mvc\Model\Message;

    class Robots extends Model
    {
        public function validation()
        {
            if ($this->type === "Old") {
                $message = new Message(
                    "Sorry, old robots are not allowed anymore",
                    "type",
                    "MyType"
                );

                $this->appendMessage($message);

                return false;
            }

            return true;
        }
    }

Пропуск столбцов
----------------
Можно указать :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` пропускать некоторые поля при создании и/или обновлении записей для того,
чтобы делегировать базе данных установку значений триггерами или по умолчанию:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public function initialize()
        {
            // Пропуск поля/столбца при всех INSERT/UPDATE операциях
            $this->skipAttributes(
                [
                    "year",
                    "price",
                ]
            );

            // Пропуск только при вставке
            $this->skipAttributesOnCreate(
                [
                    "created_at",
                ]
            );

            // Пропуск только при обновлении
            $this->skipAttributesOnUpdate(
                [
                    "modified_in",
                ]
            );
        }
    }

Эти поля будут игнорироваться при каждой операции INSERT/UPDATE во всем приложении.
Принудительно присваивание значения по умолчанию может быть достигнуто
следующим образом:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    use Phalcon\Db\RawValue;

    $robot = new Robots();

    $robot->name       = "Bender";
    $robot->year       = 1999;
    $robot->created_at = new RawValue("default");

    $robot->create();

События также могут использоваться для условного присваивания значений по умолчанию:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;
    use Phalcon\Db\RawValue;

    class Robots extends Model
    {
        public function beforeCreate()
        {
            if ($this->price > 10000) {
                $this->type = new RawValue("default");
            }
        }
    }

.. highlights::

    Никогда не используйте :doc:`Phalcon\\Db\\RawValue <../api/Phalcon_Db_RawValue>` при работе с внешними данными (такими как ввод пользователя)
    или изменяющимися данными. Значение таких полей игнорируется при связывании параметров в запросе.
    Таким образом, это может использоваться для взлома с помощью SQL инъекции.

Динамическое обновление
^^^^^^^^^^^^^^^^^^^^^^^
SQL операторы UPDATE по умолчанию включают в себя каждый столбец, определенный в модели.
Вы можете изменить определенную модель, включив динамическое обновление. В этом случае только измененные поля
попадут в окончательный SQL запрос.

В некоторых случаях это может улучшить производительность за счет снижения трафика между приложением и сервером базы данных,
это особенно помогает, когда таблица имеет BLOB/TEXT поля:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public function initialize()
        {
            $this->useDynamicUpdate(true);
        }
    }

Удаление записей
----------------
Метод :code:`Phalcon\Mvc\Model::delete()` позволяет удалить запись. Вы можете использовать его следующим образом:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = Robots::findFirst(11);

    if ($robot !== false) {
        if ($robot->delete() === false) {
            echo "К сожалению, мы не можем удалить робота прямо сейчас: \n";

            $messages = $robot->getMessages();

            foreach ($messages as $message) {
                echo $message, "\n";
            }
        } else {
            echo "Робот был успешно удален!";
        }
    }

Вы также можете удалить несколько записей путем обхода набора результатов в цикле foreach:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robots = Robots::find(
        "type = 'mechanical'"
    );

    foreach ($robots as $robot) {
        if ($robot->delete() === false) {
            echo "К сожалению, мы не можем удалить робота прямо сейчас: \n";

            $messages = $robot->getMessages();

            foreach ($messages as $message) {
                echo $message, "\n";
            }
        } else {
            echo "Робот был успешно удален!";
        }
    }

Следующие события, доступные для определения пользовательской бизнес-логики, вызываются при выполнении операции
удаления:

+-----------+--------------+----------------------------+---------------------------------------+
| Операция  | Название     | Можно остановить операцию? | Пояснение                             |
+===========+==============+============================+=======================================+
| Удаление  | beforeDelete | ДА                         | Выполняется до операции удаления      |
+-----------+--------------+----------------------------+---------------------------------------+
| Удаление  | afterDelete  | НЕТ                        | Выполняется после операции удаления   |
+-----------+--------------+----------------------------+---------------------------------------+

В событиях, указанных выше, также можно определять бизнес-логику модели:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public function beforeDelete()
        {
            if ($this->status == "A") {
                echo "Робот активен, он не может быть удален";

                return false;
            }

            return true;
        }
    }

События при ошибках валидации
-----------------------------
Другой доступный тип событий - когда в процессе проверки данных выявляются какие-либо несоответствия:

+----------------------------------+--------------------+------------------------------------------------------------------------------------+
| Операция                         | Название           | Пояснение                                                                          |
+==================================+====================+====================================================================================+
| Вставка или обновление           | notSaved           | Срабатывает, когда операция INSERT или UPDATE не выполняется по какой-либо причине |
+----------------------------------+--------------------+------------------------------------------------------------------------------------+
| Вставка, удаление или обновление | onValidationFails  | Срабатывает, когда не выполняется какая-либо операция обработки данных             |
+----------------------------------+--------------------+------------------------------------------------------------------------------------+

Независимое сопоставление столбцов
----------------------------------
ORM поддерживает независимую карту столбцов, позволяющую разработчику использовать различные именования в модели
и таблице. Phalcon зарегистрирует новые имена и будет переименовывать их при запросах к базе соответственно указанным значениям.
Это отличная возможность, если нужно переименовать поля в базе данных без необходимости беспокоиться о запросах
в коде. Достаточно изменить карту столбцов, Phalcon позаботится об остальном. Например:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public $code;

        public $theName;

        public $theType;

        public $theYear;

        public function columnMap()
        {
            // Ключи - реальные имена в таблице и
            // значения - их имена в приложении
            return [
                "id"       => "code",
                "the_name" => "theName",
                "the_type" => "theType",
                "the_year" => "theYear",
            ];
        }
    }

Затем вы можете использовать новые переменные в вашем коде:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    // Найти робота по имени
    $robot = Robots::findFirst(
        "theName = 'Voltron'"
    );

    echo $robot->theName, "\n";

    // Получить роботов, сгруппированных по типу
    $robot = Robots::find(
        [
            "order" => "theType DESC",
        ]
    );

    foreach ($robots as $robot) {
        echo "Code: ", $robot->code, "\n";
    }

    // Создать робота
    $robot = new Robots();

    $robot->code    = "10101";
    $robot->theName = "Bender";
    $robot->theType = "Industrial";
    $robot->theYear = 2999;

    $robot->save();

При переименовании столбцов примите во внимание следующее:

* Ссылки на атрибуты в отношениях/валидаторах должны использовать новые имена
* Ссылка на реальное имя столбца приведет к выбросу исключения в ORM

Независимая карта столбцов позволит вам:

* Писать приложения, используя ваши собственные правила именования
* Ликвидировать префиксы/суффиксы вендоров в вашем коде
* Изменить имена столбцов без изменения кода приложения

Операции над набором результатов
--------------------------------
Если набор результатов состоит из конечных объектов, то может гораздо проще производить операции над записями:

Обновление связанных записей
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Вместо того, чтобы делать так:

.. code-block:: php

    <?php

    $parts = $robots->getParts();

    foreach ($parts as $part) {
        $part->stock      = 100;
        $part->updated_at = time();

        if ($part->update() === false) {
            $messages = $part->getMessages();

            foreach ($messages as $message) {
                echo $message;
            }

            break;
        }
    }

Вы можете делать так:

.. code-block:: php

    <?php

    $robots->getParts()->update(
        [
            "stock"      => 100,
            "updated_at" => time(),
        ]
    );

'update' также принимает анонимную функцию, чтобы отфильтровать записи, которые должны быть обновлены:

.. code-block:: php

    <?php

    $data = [
        "stock"      => 100,
        "updated_at" => time(),
    ];

    // Обновить все части, кроме тех, чей тип базовый
    $robots->getParts()->update(
        $data,
        function ($part) {
            if ($part->type === Part::TYPE_BASIC) {
                return false;
            }

            return true;
        }
    );

Удаление связанных записей
^^^^^^^^^^^^^^^^^^^^^^^^^^
Вместо того, чтобы делать так:

.. code-block:: php

    <?php

    $parts = $robots->getParts();

    foreach ($parts as $part) {
        if ($part->delete() === false) {
            $messages = $part->getMessages();

            foreach ($messages as $message) {
                echo $message;
            }

            break;
        }
    }

Вы можете делать так:

.. code-block:: php

    <?php

    $robots->getParts()->delete();

:code:`delete()` также принимает анонимную функцию, чтобы отфильтровать записи, которые должны быть удалены:

.. code-block:: php

    <?php

    // Удалить только те, у которых поле stock больше или равно нулю
    $robots->getParts()->delete(
        function ($part) {
            if ($part->stock < 0) {
                return false;
            }

            return true;
        }
    );

Запись снимков
--------------
В определенных моделях может быть установленно сохранение снимков, когда они вызываются. Вы можете использовать эту функцию для осуществления аудита или просто для того, чтобы знать то,
какие поля были изменены в соответствии с запросом данных из дампа.

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public function initialize()
        {
            $this->keepSnapshots(true);
        }
    }

При активации этой функции приложение потребляет немного больше памяти, чтобы следить за исходными значениями, полученных из дампа.
В моделях, которые используют эту функцию, вы можете увидеть, какие поля изменились:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    // Получаем запись из базы данных
    $robot = Robots::findFirst();

    // Изменяем столбец
    $robot->name = "Other name";

    var_dump($robot->getChangedFields()); // ["name"]

    var_dump($robot->hasChanged("name")); // true

    var_dump($robot->hasChanged("type")); // false

Ссылка на другую схему
----------------------
Если модель отображает таблицу, которая находится в схеме/базе данных, отличной от заданной по умолчанию, то вы можете использовать метод :code:`setSchema()`, чтобы определить это:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public function initialize()
        {
            $this->setSchema("toys");
        }
    }

Установка нескольких баз данных
-------------------------------
В Phalcon все модели могут принадлежать к одному и тому же соединению с базой данных или иметь индивидуальное. На самом деле, когда классу
:doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>` необходимо подключиться к базе данных, он запрашивает сервис "db"
в контейнере сервисов приложения. Вы можете переопределить этот сервис, установив его в методе :code:`initialize()`:

.. code-block:: php

    <?php

    use Phalcon\Db\Adapter\Pdo\Mysql as MysqlPdo;
    use Phalcon\Db\Adapter\Pdo\PostgreSQL as PostgreSQLPdo;

    // Этот сервис возвращает базу данных MySQL
    $di->set(
        "dbMysql",
        function () {
            return new MysqlPdo(
                [
                    "host"     => "localhost",
                    "username" => "root",
                    "password" => "secret",
                    "dbname"   => "invo",
                ]
            );
        }
    );

    // Этот сервис возвращает базу данных PostgreSQL
    $di->set(
        "dbPostgres",
        function () {
            return new PostgreSQLPdo(
                [
                    "host"     => "localhost",
                    "username" => "postgres",
                    "password" => "",
                    "dbname"   => "invo",
                ]
            );
        }
    );

Затем в методе :code:`initialize()`, определим сервис соединения для модели:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public function initialize()
        {
            $this->setConnectionService("dbPostgres");
        }
    }

Но Phalcon предлагает вам больше гибкости: вы можете указать, какое соединение использовать для чтения, а какое для записи. Это особенно полезно
для балансировки нагрузки ваших баз данных, реализующих архитектуру master-slave:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public function initialize()
        {
            $this->setReadConnectionService("dbSlave");

            $this->setWriteConnectionService("dbMaster");
        }
    }

ORM также предоставляет возможность горизонтального масштабирования, позволяя вам реализовать выбор шардов (shard)
в соответствии с текущего условиями запроса:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        /**
         * Динамически выбирает шарды
         *
         * @param array $intermediate
         * @param array $bindParams
         * @param array $bindTypes
         */
        public function selectReadConnection($intermediate, $bindParams, $bindTypes)
        {
            // Проверяем, есть ли  'where' в select
            if (isset($intermediate["where"])) {
                $conditions = $intermediate["where"];

                // Выбираем возможный шард в соответствии с условиями
                if ($conditions["left"]["name"] == "id") {
                    $id = $conditions["right"]["value"];

                    if ($id > 0 && $id < 10000) {
                        return $this->getDI()->get("dbShard1");
                    }

                    if ($id > 10000) {
                        return $this->getDI()->get("dbShard2");
                    }
                }
            }

            // Используем стандартный шард
            return $this->getDI()->get("dbShard0");
        }
    }

Метод :code:`selectReadConnection()` вызывается для выбора правильного соединения, этот метод перехватывает выполнение любого нового
запроса:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = Robots::findFirst('id = 101');

Логирование низкоуровневых SQL запросов
---------------------------------------
При использовании компонентов абстракции высокого уровня, таких как  :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>`, для доступа к базе данных,
трудно понять, какие операторы в конечном итоге посылаются базе данных. :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>`
поддерживается изнутри :doc:`Phalcon\\Db <../api/Phalcon_Db>`. :doc:`Phalcon\\Logger <../api/Phalcon_Logger>` взаимодействует
с :doc:`Phalcon\\Db <../api/Phalcon_Db>`, обеспечивая возможность ведения логов на уровне абстракции базы данных, таким образом, позволяя нам логировать SQL
запросы.

.. code-block:: php

    <?php

    use Phalcon\Logger;
    use Phalcon\Events\Manager;
    use Phalcon\Logger\Adapter\File as FileLogger;
    use Phalcon\Db\Adapter\Pdo\Mysql as Connection;

    $di->set(
        "db",
        function () {
            $eventsManager = new EventsManager();

            $logger = new FileLogger("app/logs/debug.log");

            // Слушаем все события базы данных
            $eventsManager->attach(
                "db:beforeQuery",
                function ($event, $connection) use ($logger) {
                    $logger->log(
                        $connection->getSQLStatement(),
                        Logger::INFO
                    );
                }
            );

            $connection = new Connection(
                [
                    "host"     => "localhost",
                    "username" => "root",
                    "password" => "secret",
                    "dbname"   => "invo",
                ]
            );

            // Назначаем EventsManager экземпляру адаптера базы данных
            $connection->setEventsManager($eventsManager);

            return $connection;
        }
    );

Как только модель взаимодействует с соединением, все SQL запросы, которые передаются в базу данных, будут сохранены в файле:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    $robot = new Robots();

    $robot->name       = "Robby the Robot";
    $robot->created_at = "1956-07-21";

    if ($robot->save() === false) {
        echo "Не удалось сохранить робота";
    }

Упомянутый выше файл *app/logs/db.log* будет содержать что-то вроде этого:

.. code-block:: irc

    [Mon, 30 Apr 12 13:47:18 -0500][DEBUG][Resource Id #77] INSERT INTO robots
    (name, created_at) VALUES ('Robby the Robot', '1956-07-21')

Профилирование SQL запросов
---------------------------
Благодаря  :doc:`Phalcon\\Db <../api/Phalcon_Db>`, основе компонента :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>`,
возможно профилировать SQL запросы, генерируемые ORM, в целях анализа производительности операций с базой данных. При
этом вы можете диагностировать проблемы производительности и выявлять узкие места.

.. code-block:: php

    <?php

    use Phalcon\Db\Profiler as ProfilerDb;
    use Phalcon\Events\Manager as EventsManager;
    use Phalcon\Db\Adapter\Pdo\Mysql as MysqlPdo;

    $di->set(
        "profiler",
        function () {
            return new ProfilerDb();
        },
        true
    );

    $di->set(
        "db",
        function () use ($di) {
            $eventsManager = new EventsManager();

            // Получаем общий экземпляр DbProfiler
            $profiler = $di->getProfiler();

            // Слушаем все события базы данных
            $eventsManager->attach(
                "db",
                function ($event, $connection) use ($profiler) {
                    if ($event->getType() === "beforeQuery") {
                        $profiler->startProfile(
                            $connection->getSQLStatement()
                        );
                    }

                    if ($event->getType() === "afterQuery") {
                        $profiler->stopProfile();
                    }
                }
            );

            $connection = new MysqlPdo(
                [
                    "host"     => "localhost",
                    "username" => "root",
                    "password" => "secret",
                    "dbname"   => "invo",
                ]
            );

            // Назначаем EventsManager экземпляру адаптера базы данных
            $connection->setEventsManager($eventsManager);

            return $connection;
        }
    );

Профилирование некоторых запросов:

.. code-block:: php

    <?php

    use Store\Toys\Robots;

    // Отправим несколько SQL запросов в базу данных
    Robots::find();

    Robots::find(
        [
            "order" => "name",
        ]
    );

    Robots::find(
        [
            "limit" => 30,
        ]
    );

    // Получаем сгенерированные профили из профилировщика
    $profiles = $di->get("profiler")->getProfiles();

    foreach ($profiles as $profile) {
       echo "SQL запрос: ", $profile->getSQLStatement(), "\n";
       echo "Начальное время: ", $profile->getInitialTime(), "\n";
       echo "Конечное время: ", $profile->getFinalTime(), "\n";
       echo "Затраченное время: ", $profile->getTotalElapsedSeconds(), "\n";
    }

Каждый генерируемый профиль содержит продолжительность выполнения каждого запроса в миллисекундах, а также сами сгенерированные SQL запросы.

Инъекция сервисов в модели
--------------------------
Вам может потребоваться доступ к службам приложений в рамках модели. Следующий пример объясняет, как его получить:

.. code-block:: php

    <?php

    namespace Store\Toys;

    use Phalcon\Mvc\Model;

    class Robots extends Model
    {
        public function notSaved()
        {
            // Получаем сервис flash из контейнера DI
            $flash = $this->getDI()->getFlash();

            $messages = $this->getMessages();

            // Показываем сообщения проверки
            foreach ($messages as $message) {
                $flash->error($message);
            }
        }
    }

Событие "notSaved" срабатывает каждый раз, когда не удаются действия "create" или "update". Соответственно, мы показываем сообщения проверки,
получая сервис "flash" из контейнера DI. Таким образом, нам не нужно выводить сообщения после каждого сохранения.

Отключение/включение возможностей
---------------------------------
Мы внедрили в ORM механизм, который позволяет вам на лету включать/отключать конкретные особенности или глобальные опции.
Поэтому, когда вы используете ORM, можете отключить то, что вы не используете. Эти параметры также могут быть временно отключены, если требуется:

.. code-block:: php

    <?php

    use Phalcon\Mvc\Model;

    Model::setup(
        [
            "events"         => false,
            "columnRenaming" => false,
        ]
    );

Доступные опции:

+---------------------+-------------------------------------------------------------------------------------------------+---------------+
| Опция               | Описание                                                                                        | По умолчанию  |
+=====================+=================================================================================================+===============+
| events              | Включает/выключает функции обратного вызова, хуки и уведомления о событиях из всех моделей      | :code:`true`  |
+---------------------+-------------------------------------------------------------------------------------------------+---------------+
| columnRenaming      | Включает/выключает переименование столбцов                                                      | :code:`true`  |
+---------------------+-------------------------------------------------------------------------------------------------+---------------+
| notNullValidations  | ORM автоматически проверяет NOT NULL столбцы, присутствующие в таблице                          | :code:`true`  |
+---------------------+-------------------------------------------------------------------------------------------------+---------------+
| virtualForeignKeys  | Включает/выключает виртуальные внешние ключи                                                    | :code:`true`  |
+---------------------+-------------------------------------------------------------------------------------------------+---------------+
| phqlLiterals        | Включает/выключает литералы в PHQL парсере                                                      | :code:`true`  |
+---------------------+-------------------------------------------------------------------------------------------------+---------------+
| lateStateBinding    | Включает/выключает позднее статическое связывание метода :code:`Mvc\Model::cloneResultMap()`    | :code:`false` |
+---------------------+-------------------------------------------------------------------------------------------------+---------------+

Автономный компонент
--------------------
Ниже показано, как можно использовать :doc:`Phalcon\\Mvc\\Model <models>` в автономном режиме:

.. code-block:: php

    <?php

    use Phalcon\Di;
    use Phalcon\Mvc\Model;
    use Phalcon\Mvc\Model\Manager as ModelsManager;
    use Phalcon\Db\Adapter\Pdo\Sqlite as Connection;
    use Phalcon\Mvc\Model\Metadata\Memory as MetaData;

    $di = new Di();

    // Настраиваем соединение
    $di->set(
        "db",
        new Connection(
            [
                "dbname" => "sample.db",
            ]
        )
    );

    // Устанавливаем менеджер модели
    $di->set(
        "modelsManager",
        new ModelsManager()
    );

    // Используем адаптер памяти мета-данных или любой другой
    $di->set(
        "modelsMetadata",
        new MetaData()
    );

    // Создаем модель
    class Robots extends Model
    {

    }

    // Используем модель
    echo Robots::count();

.. _PDO: http://php.net/manual/ru/pdo.prepared-statements.php
