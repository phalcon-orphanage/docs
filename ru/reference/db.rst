Уровень абстракции баз данных
=============================

:doc:`Phalcon\\Db <../api/Phalcon_Db>` является компонентом, располагающимся под :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>`,
который обеспечивает уровень моделей во фреймворке. Он состоит из независимых абстракций высокого уровня для баз данных,
полностью написанных на C.

Этот компонент позволяет производить манипуляции с базой данных на более низком уровне, чем при использовании традиционных моделей.

.. highlights::

    Данное руководство не претендует на полную документацию доступных методов и аргументов. Пожалуйста, посетите: :doc:`API <../api/index>`
    для подробного изучения.

Адаптеры базы данных
--------------------
Данный компонент позволяет использовать адаптеры для инкапсуляции конкретных деталей системы баз данных. Phalcon использует PDO для подключения к базам данных. Поддерживаются следующие СУБД:

+-----------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Class                                                                                   | Описание                                                                                                                                                                                                                    |
+=========================================================================================+=============================================================================================================================================================================================================================+
| :doc:`Phalcon\\Db\\Adapter\\Pdo\\Mysql <../api/Phalcon_Db_Adapter_Pdo_Mysql>`           | Наиболее часто используемая реляционная система управления базами данных (RDBMS), которая работает как сервер, обеспечивающий многопользовательский доступ к некоторому набору баз данных                                   |
+-----------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| :doc:`Phalcon\\Db\\Adapter\\Pdo\\Postgresql <../api/Phalcon_Db_Adapter_Pdo_Postgresql>` | PostgreSQL является мощной RDBMS с открытым исходным кодом. PostgreSQL – это более чем 15 лет активного развития и проверенная архитектура, чем и завоевала прочную репутацию за надежность, целостность данных и точность. |
+-----------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| :doc:`Phalcon\\Db\\Adapter\\Pdo\\Sqlite <../api/Phalcon_Db_Adapter_Pdo_Sqlite>`         | Библиотека SQLite реализует автономную, бессерверную, не требующую конфигурации и при этом поддерживающую транзакции базу данных на основе языка SQL.                                                                       |
+-----------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Реализации собственных адаптеров
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Интерфейс :doc:`Phalcon\\Db\\AdapterInterface <../api/Phalcon_Db_AdapterInterface>` должен быть реализован для того, чтобы создать свой собственный адаптер базы данных или расширить существующий.

Диалекты баз данных
-------------------

Приложение инкапсулирует специфические детали каждого компонента баз данных в диалектах. Которые в свою очередь предоставляют адаптером общие функции и генератор SQL.

+--------------------------------------------------------------------------------+-----------------------------------------+
| Class                                                                          | Описание                                |
+================================================================================+=========================================+
| :doc:`Phalcon\\Db\\Dialect\\Mysql <../api/Phalcon_Db_Dialect_Mysql>`           | Специфичные диалекты SQL для MySQL      |
+--------------------------------------------------------------------------------+-----------------------------------------+
| :doc:`Phalcon\\Db\\Dialect\\Postgresql <../api/Phalcon_Db_Dialect_Postgresql>` | Специфичные диалекты SQL для PostgreSQL |
+--------------------------------------------------------------------------------+-----------------------------------------+
| :doc:`Phalcon\\Db\\Dialect\\Sqlite <../api/Phalcon_Db_Dialect_Sqlite>`         | Специфичные диалекты SQL для SQLite     |
+--------------------------------------------------------------------------------+-----------------------------------------+

Реализации собственных диалектов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Интерфейс :doc:`Phalcon\\Db\\DialectInterface <../api/Phalcon_Db_DialectInterface>` должен быть реализован для того, чтобы создать свой собственный диалект базы данных или расширить существующий.

Подключение к базе данных
-------------------------
Чтобы создать подключение необходимо создать экземпляр класса адаптера. Для этого требуется только массив с параметрами соединения. В приведенном примере ниже показано, как создать соединение
с обязательными и необязательными параметрами:

.. code-block:: php

    <?php

    // Обязательные
    $config = [
        "host"     => "127.0.0.1",
        "username" => "mike",
        "password" => "sigma",
        "dbname"   => "test_db",
    ];

    // Необязательные
    $config["persistent"] = false;

    // Создаем соединение
    $connection = new \Phalcon\Db\Adapter\Pdo\Mysql($config);

.. code-block:: php

    <?php

    // Обязательные
    $config = [
        "host"     => "localhost",
        "username" => "postgres",
        "password" => "secret1",
        "dbname"   => "template",
    ];

    // Необязательные
    $config["schema"] = "public";

    //  Создаем соединение
    $connection = new \Phalcon\Db\Adapter\Pdo\Postgresql($config);

.. code-block:: php

    <?php

    // Обязательные
    $config = [
        "dbname" => "/path/to/database.db",
    ];

    // Создаем соединение
    $connection = new \Phalcon\Db\Adapter\Pdo\Sqlite($config);

Настройка дополнительных параметров PDO
---------------------------------------
Вы можете установить опции PDO во время соединения, передавая параметры ‘options’:

.. code-block:: php

    <?php

    // Создаем соединение с настройками PDO
    $connection = new \Phalcon\Db\Adapter\Pdo\Mysql(
        [
            "host"     => "localhost",
            "username" => "root",
            "password" => "sigma",
            "dbname"   => "test_db",
            "options"  => [
                PDO::MYSQL_ATTR_INIT_COMMAND => "SET NAMES 'UTF8'",
                PDO::ATTR_CASE               => PDO::CASE_LOWER,
            ]
        ]
    );

Извлечение строк
----------------
:doc:`Phalcon\\Db <../api/Phalcon_Db>` предоставляет несколько методов для получения строк из таблиц.
В данном случае требуется использовать синтаксис SQL  используемой СУБД:

.. code-block:: php

    <?php

    $sql = "SELECT id, name FROM robots ORDER BY name";

    // Отправляем SQL в базу данных
    $result = $connection->query($sql);

    // Выводим на экран имя робота
    while ($robot = $result->fetch()) {
       echo $robot["name"];
    }

    // Получаем все строки из таблицы в виде массива
    $robots = $connection->fetchAll($sql);
    foreach ($robots as $robot) {
       echo $robot["name"];
    }

    // Получаем только первую строку из таблицы
    $robot = $connection->fetchOne($sql);

По умолчанию эти методы создают массив с ассоциативными и числовыми индексами.
Вы можете изменить это поведение с помощью :code:`Phalcon\Db\Result::setFetchMode()`.
Этот метод получает константу, которая определяет, какой тип индекса требуется.

+---------------------------------+-----------------------------------------------------------+
| Константа                       | Описание                                                  |
+=================================+===========================================================+
| :code:`Phalcon\Db::FETCH_NUM`   | Возвращает массив с числовыми индексами                   |
+---------------------------------+-----------------------------------------------------------+
| :code:`Phalcon\Db::FETCH_ASSOC` | Возвращает массив с ассоциативными индексами              |
+---------------------------------+-----------------------------------------------------------+
| :code:`Phalcon\Db::FETCH_BOTH`  | Возвращает массив с ассоциативными и числовыми индексами  |
+---------------------------------+-----------------------------------------------------------+
| :code:`Phalcon\Db::FETCH_OBJ`   | Возвращает объект вместо массива                          |
+---------------------------------+-----------------------------------------------------------+

.. code-block:: php

    <?php

    $sql = "SELECT id, name FROM robots ORDER BY name";
    $result = $connection->query($sql);

    $result->setFetchMode(Phalcon\Db::FETCH_NUM);
    while ($robot = $result->fetch()) {
       echo $robot[0];
    }

:code:`Phalcon\Db::query()` возвращает экземпляр класса :doc:`Phalcon\\Db\\Result\\Pdo <../api/Phalcon_Db_Result_Pdo>`.
Эти объекты инкапсулируют все методы, которые связаны с возвращаемым набором данных, т.е. перебор набора данных,
поиск конкретной записи, получение количества строк в наборе данных и т.д.

.. code-block:: php

    <?php

    $sql = "SELECT id, name FROM robots";
    $result = $connection->query($sql);

    // Перебор набора данных
    while ($robot = $result->fetch()) {
       echo $robot["name"];
    }

    // Получение третьей строки
    $result->seek(2);
    $robot = $result->fetch();

    // Получение количества строк в наборе данных
    echo $result->numRows();

Подготавливаемые запросы
------------------------
Подготавливаемые запросы также поддерживается в  :doc:`Phalcon\\Db <../api/Phalcon_Db>`.Хотя при ее использовании есть
минимальное влияние на производительность, рекомендуется использовать эту методику, чтобы исключить возможность
SQL инъекций в  вашем коде. Поддерживаются как именованные, так и неименованные псевдопеременные. Связывание параметров
может просто быть достигнуто следующим образом:

.. code-block:: php

    <?php

    // Подготовленный запрос с неименованными псевдопеременными
    $sql    = "SELECT * FROM robots WHERE name = ? ORDER BY name";
    $result = $connection->query(
        $sql,
        [
            "Wall-E",
        ]
    );

    // Подготовленный запрос с именованными псевдопеременными
    $sql     = "INSERT INTO `robots`(name`, year) VALUES (:name, :year)";
    $success = $connection->query(
        $sql,
        [
            "name" => "Astro Boy",
            "year" => 1952,
        ]
    );

When using numeric placeholders, you will need to define them as integers i.e. 1 or 2. In this case "1" or "2"
are considered strings and not numbers, so the placeholder could not be successfully replaced. With any adapter
data are automatically escaped using `PDO Quote <http://www.php.net/manual/en/pdo.quote.php>`_.

This function takes into account the connection charset, so its recommended to define the correct charset
in the connection parameters or in your database server configuration, as a wrong
charset will produce undesired effects when storing or retrieving data.

Also, you can pass your parameters directly to the execute/query methods. In this case
bound parameters are directly passed to PDO:

.. code-block:: php

    <?php

    // Binding with PDO placeholders
    $sql    = "SELECT * FROM robots WHERE name = ? ORDER BY name";
    $result = $connection->query(
        $sql,
        [
            1 => "Wall-E",
        ]
    );

Вставка/Обновление/Удаление строк
---------------------------------
Вставлять, обновлять и удалять строки вы можете с помощью стандартного SQL запроса или использовать методы, предоставляемые классом:

.. code-block:: php

    <?php

    // Вставка с помощью стандартного SQL запроса
    $sql     = "INSERT INTO `robots`(`name`, `year`) VALUES ('Astro Boy', 1952)";
    $success = $connection->execute($sql);

    // с помощью подготовленного запроса
    $sql     = "INSERT INTO `robots`(`name`, `year`) VALUES (?, ?)";
    $success = $connection->execute(
        $sql,
        [
            "Astro Boy",
            1952,
        ]
    );

    // Динамическое создание запроса с помощью метода класса
    $success = $connection->insert(
        "robots",
        [
            "Astro Boy",
            1952,
        ],
        [
            "name",
            "year",
        ],
    );

    // Generating dynamically the necessary SQL (another syntax)
    $success = $connection->insertAsDict(
        "robots",
        [
            "name" => "Astro Boy",
            "year" => 1952,
        ]
    );

    // Обновление с помощью стандартного SQL запроса
    $sql     = "UPDATE `robots` SET `name` = 'Astro boy' WHERE `id` = 101";
    $success = $connection->execute($sql);

    // с помощью подготовленного запроса
    $sql     = "UPDATE `robots` SET `name` = ? WHERE `id` = ?";
    $success = $connection->execute(
        $sql,
        [
            "Astro Boy",
            101,
        ]
    );

    // Динамическое создание запроса с помощью метода класса
    $success = $connection->update(
        "robots",
        [
            "name",
        ],
        [
            "New Astro Boy",
        ],
        "id = 101" // Внимание! Значения не экранируются
    );

    // Динамическое создание запроса с помощью метода класса (другой синтаксис)
    $success = $connection->updateAsDict(
        "robots",
        [
            "name" => "New Astro Boy",
        ],
        "id = 101" // Внимание! Значения не экранируются
    );

    // С экранированием условий
    $success = $connection->update(
        "robots",
        [
            "name",
        ],
        [
            "New Astro Boy",
        ],
        [
            "conditions" => "id = ?",
            "bind"       => [101],
            "bindTypes"  => [PDO::PARAM_INT], // Необязательный параметр
        ]
    );
    $success = $connection->updateAsDict(
        "robots",
        [
            "name" => "New Astro Boy",
        ],
        [
            "conditions" => "id = ?",
            "bind"       => [101],
            "bindTypes"  => [PDO::PARAM_INT], // Необязательный параметр
        ]
    );

    // Удаление с помощью стандартного SQL запроса
    $sql     = "DELETE `robots` WHERE `id` = 101";
    $success = $connection->execute($sql);

    // с помощью подготовленного запроса
    $sql     = "DELETE `robots` WHERE `id` = ?";
    $success = $connection->execute($sql, [101]);

    // Динамическое создание запроса с помощью метода класса
    $success = $connection->delete(
        "robots",
        "id = ?",
        [
            101,
        ]
    );

Транзакции и вложенные транзакции
---------------------------------
Работа с транзакциями поддерживается с помощью PDO.  Манипуляции с данными внутри транзакции часто увеличивает
скорость работы базы данных на большинстве систем.

.. code-block:: php

    <?php

    try {
        // Начало новой транзакции
        $connection->begin();

        // Выполнение нескольких команд SQL
        $connection->execute("DELETE `robots` WHERE `id` = 101");
        $connection->execute("DELETE `robots` WHERE `id` = 102");
        $connection->execute("DELETE `robots` WHERE `id` = 103");

        // Фиксируем изменения в транзакции, если все хорошо.
        $connection->commit();
    } catch (Exception $e) {
        // В случаи исключения откатываем все изменения
        $connection->rollback();
    }

В дополнение к стандартным транзакциям, :doc:`Phalcon\\Db <../api/Phalcon_Db>` обеспечивает встроенную поддержку `вложенных транзакции`_
(если база данных поддерживает их). Когда вы вызываете метод begin() во второй раз – создается вложенная транзакция:

.. code-block:: php

    <?php

    try {
        // Начало новой транзакции
        $connection->begin();

        // Выполнение нескольких команд SQL
        $connection->execute("DELETE `robots` WHERE `id` = 101");

        try {
            // Начало вложенной транзакции
            $connection->begin();

            // Выполнение нескольких команд SQL во вложенной транзакции
            $connection->execute("DELETE `robots` WHERE `id` = 102");
            $connection->execute("DELETE `robots` WHERE `id` = 103");

            // Создаем точку сохранения
            $connection->commit();
        } catch (Exception $e) {
            // В случаи исключения откатываем все изменения
            $connection->rollback();
        }

        // Продолжаем Выполнение нескольких команд SQL
        $connection->execute("DELETE `robots` WHERE `id` = 104");

        // Фиксируем изменения в транзакции, если все хорошо.
        $connection->commit();
    } catch (Exception $e) {
        // В случаи исключения откатываем все изменения
        $connection->rollback();
    }

События базы данных
-------------------
:doc:`Phalcon\\Db <../api/Phalcon_Db>` способен передавать :doc:`EventsManager <events>`, если оно есть.
Некоторые события при возвращении булева значения ‘false’ могут остановить выполняемую операцию. Поддерживаются
следующие события:

+---------------------+-----------------------------------------------------------+-------------------------+
| Название            | Когда срабатывает                                         | Может остановить работу?|
+=====================+===========================================================+=========================+
| afterConnect        | После успешного подключения к БД                          | Нет                     |
+---------------------+-----------------------------------------------------------+-------------------------+
| beforeQuery         | Перед отправкой SQL в БД                                  | Да                      |
+---------------------+-----------------------------------------------------------+-------------------------+
| afterQuery          | После отправки запроса в БД                               | Нет                     |
+---------------------+-----------------------------------------------------------+-------------------------+
| beforeDisconnect    | Перед закрытием временного соединения с БД                | Нет                     |
+---------------------+-----------------------------------------------------------+-------------------------+
| beginTransaction    | Перед началом транзакции                                  | Нет                     |
+---------------------+-----------------------------------------------------------+-------------------------+
| rollbackTransaction | Перед откатом изменений произведенных в транзакции        | Нет                     |
+---------------------+-----------------------------------------------------------+-------------------------+
| commitTransaction   | Перед фиксацией транзакции                                | Нет                     |
+---------------------+-----------------------------------------------------------+-------------------------+

Привязать менеджер событий к соединению просто, :doc:`Phalcon\\Db <../api/Phalcon_Db>` будет вызывать событие с именем “db”:

.. code-block:: php

    <?php

    use Phalcon\Events\Manager as EventsManager;
    use Phalcon\Db\Adapter\Pdo\Mysql as Connection;

    $eventsManager = new EventsManager();

    // Прослушать все события базы данных
    $eventsManager->attach('db', $dbListener);

    $connection = new Connection(
        [
            "host"     => "localhost",
            "username" => "root",
            "password" => "secret",
            "dbname"   => "invo",
        ]
    );

    // Назначаем менеджер событий экземпляру адаптера БД
    $connection->setEventsManager($eventsManager);

Иметь возможность остановить выполнение SQL очень полезно, если вы хотите осуществить последнюю проверку SQL на наличие SQL инъекций:

.. code-block:: php

    <?php

    use Phalcon\Events\Event;

    $eventsManager->attach(
        "db:beforeQuery",
        function (Event $event, $connection) {
            $sql = $connection->getSQLStatement();

            // Проверка на наличие вредоносных ключевых слов в SQL
            if (preg_match("/DROP|ALTER/i", $sql)) {
                // DROP / ALTER операции не разрешено использовать в приложении,
                // это должно быть SQL инъекция!
                return false;
            }

            // Все хорошо
            return true;
        }
    );

Профилирование запросов SQL
---------------------------
:doc:`Phalcon\\Db <../api/Phalcon_Db>` включает в себя компонент профилирования SQL запросов под
названием :doc:`Phalcon\\Db\\Profiler <../api/Phalcon_Db_Profiler>`, который используется для анализа
производительности запросов к базе данных для того, чтобы диагностировать проблему с производительностью
и обнаружить узкие места.

Профилировать базу данных легко с помощью :doc:`Phalcon\\Db\\Profiler <../api/Phalcon_Db_Profiler>`:

.. code-block:: php

    <?php

    use Phalcon\Events\Event;
    use Phalcon\Events\Manager as EventsManager;
    use Phalcon\Db\Profiler as DbProfiler;

    $eventsManager = new EventsManager();

    $profiler = new DbProfiler();

    // Слушаем все события БД
    $eventsManager->attach(
        "db",
        function (Event $event, $connection) use ($profiler) {
            if ($event->getType() === "beforeQuery") {
                $sql = $connection->getSQLStatement();

                // Запуск профайлера с текущим соединением
                $profiler->startProfile($sql);
            }

            if ($event->getType() === "afterQuery") {
                // Остановка текущего профайлера
                $profiler->stopProfile();
            }
        }
    );

    // Назначаем менеджер событий соединению
    $connection->setEventsManager($eventsManager);

    $sql = "SELECT buyer_name, quantity, product_name "
         . "FROM buyers "
         . "LEFT JOIN products ON buyers.pid = products.id";

    // Выполняем SQL запрос
    $connection->query($sql);

    // Получаем последний профиль в профайлере
    $profile = $profiler->getLastProfile();

    echo "SQL Statement: ", $profile->getSQLStatement(), "\n";
    echo "Start Time: ", $profile->getInitialTime(), "\n";
    echo "Final Time: ", $profile->getFinalTime(), "\n";
    echo "Total Elapsed Time: ", $profile->getTotalElapsedSeconds(), "\n";

Вы также можете создать свой собственный компонент профилирования на основе :doc:`Phalcon\\Db\\Profiler <../api/Phalcon_Db_Profiler>`
для записи статистики запросов к БД в режиме реального времени:

.. code-block:: php

    <?php

    use Phalcon\Events\Manager as EventsManager;
    use Phalcon\Db\Profiler as Profiler;
    use Phalcon\Db\Profiler\Item as Item;

    class DbProfiler extends Profiler
    {
        /**
         * Выполняется перед отправкой SQL запроса на сервер БД
         */
        public function beforeStartProfile(Item $profile)
        {
            echo $profile->getSQLStatement();
        }

        /**
         * Выполняется после отправки SQL запроса на сервер БД
         */
        public function afterEndProfile(Item $profile)
        {
            echo $profile->getTotalElapsedSeconds();
        }
    }

    // Создание менеджера событий
    $eventsManager = new EventsManager();

    // Создание слушателя
    $dbProfiler = new DbProfiler();

    // Прикрепляем слушателя ко всем событиям базы данных
    $eventsManager->attach("db", $dbProfiler);

Логирование SQL запросов
------------------------
Использование компонентов высокого уровня абстракции для доступа к базам данных, таких как
:doc:`Phalcon\\Db <../api/Phalcon_Db>`, усложняет понимание того, какие запросы отправляются в базу данных.
:doc:`Phalcon\\Logger <../api/Phalcon_Logger>` взаимодействует с :doc:`Phalcon\\Db <../api/Phalcon_Db>`,
обеспечивая возможность логирования в слое абстракции базы данных.

.. code-block:: php

    <?php

    use Phalcon\Logger;
    use Phalcon\Events\Event;
    use Phalcon\Events\Manager as EventsManager;
    use Phalcon\Logger\Adapter\File as FileLogger;

    $eventsManager = new EventsManager();

    $logger = new FileLogger("app/logs/db.log");

    $eventsManager->attach(
        "db:beforeQuery",
        function (Event $event, $connection) use ($logger) {
            $sql = $connection->getSQLStatement();

            $logger->log($sql, Logger::INFO);
        }
    );

    // Назначаем менеджер событий соединению
    $connection->setEventsManager($eventsManager);

    // Выполняем несколько SQL запросов
    $connection->insert(
        "products",
        [
            "Hot pepper",
            3.50,
        ],
        [
            "name",
            "price",
        ]
    );

Упомянутый выше файл *app/logs/db.log* будет содержать что-то похожее на это:

.. code-block:: php

    [Sun, 29 Apr 12 22:35:26 -0500][DEBUG][Resource Id #77] INSERT INTO products
    (name, price) VALUES ('Hot pepper', 3.50)


Реализация собственного логера
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Вы можете реализовать свой собственный класс логера запросов к базе данных, путем создания класса, который реализует
единственный метод, именуемый «log». Метод должен принимать строку в качестве первого аргумента. Затем Вы можете
передать ваш объект логера в  метод :code:`Phalcon\Db::setLogger()`, после чего любые выполняемые запросы SQL будут
вызывать этот метод для логирования результата запроса.

Описание Таблиц / Представлений
-------------------------------
:doc:`Phalcon\\Db <../api/Phalcon_Db>` также предоставляет методы для получения подробной информации о таблицах и представлениях:

.. code-block:: php

    <?php

    // Получаем таблицы из базы данных test_db
    $tables = $connection->listTables("test_db");

    // Есть ли таблица 'robots' в базе данных?
    $exists = $connection->tableExists("robots");

    // Получаем имена, типы данных и свойства полей таблицы 'robots'
    $fields = $connection->describeColumns("robots");
    foreach ($fields as $field) {
        echo "Column Type: ", $field["Type"];
    }

    // Получаем индексы таблицы 'robots'
    $indexes = $connection->describeIndexes("robots");
    foreach ($indexes as $index) {
        print_r(
            $index->getColumns()
        );
    }

    // Получаем внешние ключи на таблицу 'robots'
    $references = $connection->describeReferences("robots");
    foreach ($references as $reference) {
        // Выводим на экран ссылаемые столбцы
        print_r(
            $reference->getReferencedColumns()
        );
    }

Таблица описания  очень похожа на результат команды “DESCRIBE” в MySQL, она содержит следующую информацию:

+---------+----------------------------------------------------------+
| Индексы | Описание                                                 |
+=========+==========================================================+
| Field   | Имя поля                                                 |
+---------+----------------------------------------------------------+
| Type    | Тип столбца                                              |
+---------+----------------------------------------------------------+
| Key     | Является ли столбец частью первичного ключа или индексом?|
+---------+----------------------------------------------------------+
| Null    | Допускается ли значение NULL.                            |
+---------+----------------------------------------------------------+

Методы для получения сведений о представлениях также реализованы для всех поддерживаемых баз данных:

.. code-block:: php

    <?php

    // Получить все представления из базы данных ’test_db’
    $tables = $connection->listViews("test_db");

    // Есть ли представление ‘robots’ в базе данных?
    $exists = $connection->viewExists("robots");

Создание / Изменение / удаление таблиц
--------------------------------------
Различные системы баз данных (MySQL, PostgreSQL и др.) предоставляют возможность создавать, изменять
или удалять таблицы с использованием  таких команды как CREATE, ALTER или DROP. Синтаксис SQL отличается в
зависимости от того, какая база данных используется системой.
:doc:`Phalcon\\Db <../api/Phalcon_Db>` предлагает единый интерфейс для изменения таблиц, без необходимости
дифференцировать синтаксис SQL на основании системы хранения данных.

Создание таблиц
^^^^^^^^^^^^^^^
В следующем примере показано, как создать таблицу:

.. code-block:: php

    <?php

    use \Phalcon\Db\Column as Column;

    $connection->createTable(
        "robots",
        null,
        [
           "columns" => [
                new Column(
                    "id",
                    [
                        "type"          => Column::TYPE_INTEGER,
                        "size"          => 10,
                        "notNull"       => true,
                        "autoIncrement" => true,
                        "primary"       => true,
                    ]
                ),
                new Column(
                    "name",
                    [
                        "type"    => Column::TYPE_VARCHAR,
                        "size"    => 70,
                        "notNull" => true,
                    ]
                ),
                new Column(
                    "year",
                    [
                        "type"    => Column::TYPE_INTEGER,
                        "size"    => 11,
                        "notNull" => true,
                    ]
                ),
            ]
        ]
    );

:code:`Phalcon\Db::createTable()` принимает ассоциативный массив описывающий таблицу. Столбцы определяются классом
:doc:`Phalcon\\Db\\Column <../api/Phalcon_Db_Column>`. В таблице ниже показаны варианты, доступные для определения
столбца:

+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| Опция           | Описани                                                                                                                                    | Необязательный? |
+=================+============================================================================================================================================+=================+
| "type"          | Тип столбца. Должен быть  константой быть :doc:`Phalcon\\Db\\Column <../api/Phalcon_Db_Column>` constant (см. ниже список)                 | Нет             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "primary"       | True, если столбец является частью первичного ключа таблицы                                                                                | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "size"          | Некоторые типы столбцов, такие как VARCHAR или INTEGER, могут иметь определенный размер                                                    | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "scale"         | DECIMAL или NUMBER столбцы могут  указывать точность (до какого десятичного знака требуется хранить числа).                                | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "unsigned"      | INTEGER столбцы могут быть знаковыми или беззнаковыми. Эта опция не распространяется на другие типы столбцов.                              | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "notNull"       | Может ли столбец хранить нулевые значения?                                                                                                 | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "default"       | Default value (when used with :code:`"notNull" => true`).                                                                                  | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "autoIncrement" | С помощью этой опции, столбец заполняется автоматически с автоинкрементным целым. Только один столбец в таблице может иметь этот атрибут.  | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "bind"          | Одна из BIND_TYPE_* констант говорящая, как колонки должны быть привязаны перед сохранением.                                               | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "first"         | Колонки должны быть расположены на первой позиции в порядке столбцов                                                                       | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "after"         | Колонка должна быть расположена после указанного столбца                                                                                   | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+

:doc:`Phalcon\\Db <../api/Phalcon_Db>` поддерживает следующие типы столбцов базы данных:

* :code:`Phalcon\Db\Column::TYPE_INTEGER`
* :code:`Phalcon\Db\Column::TYPE_DATE`
* :code:`Phalcon\Db\Column::TYPE_VARCHAR`
* :code:`Phalcon\Db\Column::TYPE_DECIMAL`
* :code:`Phalcon\Db\Column::TYPE_DATETIME`
* :code:`Phalcon\Db\Column::TYPE_CHAR`
* :code:`Phalcon\Db\Column::TYPE_TEXT`

Ассоциативный массив, переданный в  :code:`Phalcon\Db::createTable()` может иметь возможных ключей:

+--------------+----------------------------------------------------------------------------------------------------------------------------------------+------------------+
| Индекс       | Описание                                                                                                                               | Необязательный?  |
+==============+========================================================================================================================================+==================+
| "columns"    | Массив с набором столбцов таблицы определен с :doc:`Phalcon\\Db\\Column <../api/Phalcon_Db_Column>`                                    | Нет              |
+--------------+----------------------------------------------------------------------------------------------------------------------------------------+------------------+
| "indexes"    | Массив с набором индексов таблицы, определенные с :doc:`Phalcon\\Db\\Index <../api/Phalcon_Db_Index>`                                  | Да               |
+--------------+----------------------------------------------------------------------------------------------------------------------------------------+------------------+
| "references" | Массив с набором ссылок на таблицы (внешние ключи), определенный с :doc:`Phalcon\\Db\\Reference <../api/Phalcon_Db_Reference>`         | Да               |
+--------------+----------------------------------------------------------------------------------------------------------------------------------------+------------------+
| "options"    | Массив с набором опций для создания таблицы. Эти опции часто связаны с системой базы данных, в которых миграции был сгенерирован.      | Да               |
+--------------+----------------------------------------------------------------------------------------------------------------------------------------+------------------+

Изменение таблиц
^^^^^^^^^^^^^^^^
Если ваше приложение растет, вам, возможно, потребуется вносить изменения в  базу данных, как часть рефакторинга или
добавление нового функционала. Не все базы данных позволяют изменять существующие столбцы или добавить столбцы между
двумя существующими. :doc:`Phalcon\\Db <../api/Phalcon_Db>` ограничено  этими особенностями реализации.

.. code-block:: php

    <?php

    use Phalcon\Db\Column as Column;

    // Добавляем новый столбец
    $connection->addColumn(
        "robots",
        null,
        new Column(
            "robot_type",
            [
                "type"    => Column::TYPE_VARCHAR,
                "size"    => 32,
                "notNull" => true,
                "after"   => "name",
            ]
        )
    );

    // Изменение существующего столбца
    $connection->modifyColumn(
        "robots",
        null,
        new Column(
            "name",
            [
                "type"    => Column::TYPE_VARCHAR,
                "size"    => 40,
                "notNull" => true,
            ]
        )
    );

    // Удаление столбца "name"
    $connection->dropColumn(
        "robots",
        null,
        "name"
    );

Удаление таблицы
^^^^^^^^^^^^^^^^
Пример удаления таблицы:

.. code-block:: php

    <?php

    // Удаление таблицы “robots” из активной базы данных
    $connection->dropTable("robots");

    // Удаление таблицы "robots" из базы данных "machines"
    $connection->dropTable("robots", "machines");

.. _PDO: http://www.php.net/manual/en/book.pdo.php
.. _`вложенных транзакции`: http://en.wikipedia.org/wiki/Nested_transaction
