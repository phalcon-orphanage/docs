Уровень абстракции баз данных
=============================

:doc:`Phalcon\\Db <../api/Phalcon_Db>` является компонентом, располагающимся под :doc:`Phalcon\\Mvc\\Model <../api/Phalcon_Mvc_Model>`,
который обеспечивает уровень моделей во фреймворке. Он состоит из независимых абстракций высокого уровня для баз данных,
полностью написанных на C.

Этот компонент позволяет производить манипуляции с базой данных на более низком уровне, чем при использовании традиционных моделей.

.. highlights::

    Данное руководство не претендует на полную документацию доступных методов и аргументов. Пожалуйста, посетите: :doc:`API <../api/index>`
    для подробного изучения.

Адаптеры базы данных
--------------------
Данный компонент позволяет использовать адаптеры для инкапсуляции конкретных деталей системы баз данных. Phalcon использует PDO для подключения к базам данных. Поддерживаются следующие СУБД:

+------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------+
| Имя        | Описание                                                                                                                                                                                                                             | API                                                                                     |
+============+======================================================================================================================================================================================================================================+=========================================================================================+
| MySQL      | Наиболее часто используемая реляционная система управления базами данных (RDBMS), которая работает как сервер, обеспечивающий многопользовательский доступ к некоторому набору баз данных                                            | :doc:`Phalcon\\Db\\Adapter\\Pdo\\Mysql <../api/Phalcon_Db_Adapter_Pdo_Mysql>`           |
+------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------+
| PostgreSQL | PostgreSQL является мощной RDBMS с открытым исходным кодом. PostgreSQL – это более чем 15 лет активного развития и проверенная архитектура, чем и завоевала прочную репутацию за надежность, целостность данных и точность.          | :doc:`Phalcon\\Db\\Adapter\\Pdo\\Postgresql <../api/Phalcon_Db_Adapter_Pdo_Postgresql>` |
+------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------+
| SQLite     | Библиотека SQLite реализует автономную, бессерверную, не требующую конфигурации и при этом поддерживающую транзакции базу данных на основе языка SQL.                                                                                | :doc:`Phalcon\\Db\\Adapter\\Pdo\\Sqlite <../api/Phalcon_Db_Adapter_Pdo_Sqlite>`         |
+------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------+
| Oracle     | Oracle является объектно-реляционной системой управления базами данных, производится и продается компанией Oracle Corporation.                                                                                                       | :doc:`Phalcon\\Db\\Adapter\\Pdo\\Oracle <../api/Phalcon_Db_Adapter_Pdo_Oracle>`         |
+------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------+

Реализации собственных адаптеров
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Интерфейс :doc:`Phalcon\\Db\\AdapterInterface <../api/Phalcon_Db_AdapterInterface>` должен быть реализован для того, чтобы создать свой собственный адаптер базы данных или расширить существующий.

Диалекты баз данных
-------------------

Приложение инкапсулирует специфические детали каждого компонента баз данных в диалектах. Которые в свою очередь предоставляют адаптером общие функции и генератор SQL.

+------------+-----------------------------------------------------+--------------------------------------------------------------------------------+
| Имя        | Описание                                            | API                                                                            |
+============+=====================================================+================================================================================+
| MySQL      | Специфичные диалекты SQL для MySQL                  | :doc:`Phalcon\\Db\\Dialect\\Mysql <../api/Phalcon_Db_Dialect_Mysql>`           |
+------------+-----------------------------------------------------+--------------------------------------------------------------------------------+
| PostgreSQL | Специфичные диалекты SQL для PostgreSQL             | :doc:`Phalcon\\Db\\Dialect\\Postgresql <../api/Phalcon_Db_Dialect_Postgresql>` |
+------------+-----------------------------------------------------+--------------------------------------------------------------------------------+
| SQLite     | Специфичные диалекты SQL для SQLite                 | :doc:`Phalcon\\Db\\Dialect\\Sqlite <../api/Phalcon_Db_Dialect_Sqlite>`         |
+------------+-----------------------------------------------------+--------------------------------------------------------------------------------+
| Oracle     | Специфичные диалекты SQL для Oracle                 | :doc:`Phalcon\\Db\\Dialect\\Oracle <../api/Phalcon_Db_Dialect_Oracle>`         |
+------------+-----------------------------------------------------+--------------------------------------------------------------------------------+

Реализации собственных диалектов
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Интерфейс :doc:`Phalcon\\Db\\DialectInterface <../api/Phalcon_Db_DialectInterface>` должен быть реализован для того, чтобы создать свой собственный диалект базы данных или расширить существующий.

Подключение к базе данных
-------------------------
Чтобы создать подключение необходимо создать экземпляр класса адаптера. Для этого требуется только массив с параметрами соединения. В приведенном примере ниже показано, как создать соединение
с обязательными и необязательными параметрами:

.. code-block:: php

    <?php

    // Обязательные
    $config = array(
        "host"     => "127.0.0.1",
        "username" => "mike",
        "password" => "sigma",
        "dbname"   => "test_db"
    );

    // Необязательные
    $config["persistent"] = false;

    // Создаем соединение
    $connection = new \Phalcon\Db\Adapter\Pdo\Mysql($config);

.. code-block:: php

    <?php

    // Обязательные
    $config = array(
        "host"     => "localhost",
        "username" => "postgres",
        "password" => "secret1",
        "dbname"   => "template"
    );

    // Необязательные
    $config["schema"] = "public";

    //  Создаем соединение
    $connection = new \Phalcon\Db\Adapter\Pdo\Postgresql($config);

.. code-block:: php

    <?php

    // Обязательные
    $config = array(
        "dbname" => "/path/to/database.db"
    );

    // Создаем соединение
    $connection = new \Phalcon\Db\Adapter\Pdo\Sqlite($config);

.. code-block:: php

    <?php

    // Базовая конфигурация
    $config = array(
        'username' => 'scott',
        'password' => 'tiger',
        'dbname'   => '192.168.10.145/orcl'
    );

    // Расширенная конфигурация
    $config = array(
        'dbname'   => '(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=localhost)(PORT=1521)))(CONNECT_DATA=(SERVICE_NAME=xe)(FAILOVER_MODE=(TYPE=SELECT)(METHOD=BASIC)(RETRIES=20)(DELAY=5))))',
        'username' => 'scott',
        'password' => 'tiger',
        'charset'  => 'AL32UTF8'
    );

    // Создаем соединение
    $connection = new \Phalcon\Db\Adapter\Pdo\Oracle($config);

Настройка дополнительных параметров PDO
---------------------------------------
Вы можете установить опции PDO во время соединения, передавая параметры ‘options’:

.. code-block:: php

    <?php

    // Создаем соединение с настройками PDO
    $connection = new \Phalcon\Db\Adapter\Pdo\Mysql(
        array(
            "host"     => "localhost",
            "username" => "root",
            "password" => "sigma",
            "dbname"   => "test_db",
            "options"  => array(
                PDO::MYSQL_ATTR_INIT_COMMAND => "SET NAMES \'UTF8\'",
                PDO::ATTR_CASE               => PDO::CASE_LOWER
            )
        )
    );

Извлечение строк
----------------
:doc:`Phalcon\\Db <../api/Phalcon_Db>` предоставляет несколько методов для получения строк из таблиц.
В данном случае требуется использовать синтаксис SQL  используемой СУБД:

.. code-block:: php

    <?php

    $sql = "SELECT id, name FROM robots ORDER BY name";

    // Отправляем SQL в базу данных
    $result = $connection->query($sql);

    // Выводим на экран имя робота
    while ($robot = $result->fetch()) {
       echo $robot["name"];
    }

    // Получаем все строки из таблицы в виде массива
    $robots = $connection->fetchAll($sql);
    foreach ($robots as $robot) {
       echo $robot["name"];
    }

    // Получаем только первую строку из таблицы
    $robot = $connection->fetchOne($sql);

По умолчанию эти методы создают массив с ассоциативными и числовыми индексами.
Вы можете изменить это поведение с помощью Phalcon\\Db\\Result::setFetchMode().
Этот метод получает константу, которая определяет, какой тип индекса требуется.

+--------------------------+-----------------------------------------------------------+
| Константа                | Описание                                                  |
+==========================+===========================================================+
| Phalcon\\Db::FETCH_NUM   | Возвращает массив с числовыми индексами                   |
+--------------------------+-----------------------------------------------------------+
| Phalcon\\Db::FETCH_ASSOC | Возвращает массив с ассоциативными индексами              |
+--------------------------+-----------------------------------------------------------+
| Phalcon\\Db::FETCH_BOTH  | Возвращает массив с ассоциативными и числовыми индексами  |
+--------------------------+-----------------------------------------------------------+
| Phalcon\\Db::FETCH_OBJ   | Возвращает объект вместо массива                          |
+--------------------------+-----------------------------------------------------------+

.. code-block:: php

    <?php

    $sql = "SELECT id, name FROM robots ORDER BY name";
    $result = $connection->query($sql);

    $result->setFetchMode(Phalcon\Db::FETCH_NUM);
    while ($robot = $result->fetch()) {
       echo $robot[0];
    }

Phalcon\\Db::query() возвращает экземпляр класса :doc:`Phalcon\\Db\\Result\\Pdo <../api/Phalcon_Db_Result_Pdo>`.
Эти объекты инкапсулируют все методы, которые связаны с возвращаемым набором данных, т.е. перебор набора данных,
поиск конкретной записи, получение количества строк в наборе данных и т.д.

.. code-block:: php

    <?php

    $sql = "SELECT id, name FROM robots";
    $result = $connection->query($sql);

    //  Перебор набора данных
    while ($robot = $result->fetch()) {
       echo $robot["name"];
    }

    // Получение третьей строки
    $result->seek(2);
    $robot = $result->fetch();

    // Получение количества строк в наборе данных
    echo $result->numRows();

Подготавливаемые запросы
------------------------
Подготавливаемые запросы также поддерживается в  :doc:`Phalcon\\Db <../api/Phalcon_Db>`.Хотя при ее использовании есть
минимальное влияние на производительность, рекомендуется использовать эту методику, чтобы исключить возможность
SQL инъекций в  вашем коде. Поддерживаются как именованные, так и неименованные псевдопеременные. Связывание параметров
может просто быть достигнуто следующим образом:

.. code-block:: php

    <?php

    // Подготовленный запрос с неименованными псевдопеременными
    $sql    = "SELECT * FROM robots WHERE name = ? ORDER BY name";
    $result = $connection->query($sql, array("Wall-E"));

    // Подготовленный запрос с именованными псевдопеременными
    $sql     = "INSERT INTO `robots`(name`, year) VALUES (:name, :year)";
    $success = $connection->query($sql, array("name" => "Astro Boy", "year" => 1952));

When using numeric placeholders, you will need to define them as integers i.e. 1 or 2. In this case "1" or "2"
are considered strings and not numbers, so the placeholder could not be successfully replaced. With any adapter
data are automatically escaped using `PDO Quote <http://www.php.net/manual/en/pdo.quote.php>`_.

This function takes into account the connection charset, so its recommended to define the correct charset
in the connection parameters or in your database server configuration, as a wrong
charset will produce undesired effects when storing or retrieving data.

Also, you can pass your parameterers directly to the execute/query methods. In this case
bound parameters are directly passed to PDO:

.. code-block:: php

    <?php

    // Binding with PDO placeholders
    $sql    = "SELECT * FROM robots WHERE name = ? ORDER BY name";
    $result = $connection->query($sql, array(1 => "Wall-E"));

Вставка/Обновление/Удаление строк
---------------------------------
Вставлять, обновлять и удалять строки вы можете с помощью стандартного SQL запроса или использовать методы, предоставляемые классом:

.. code-block:: php

    <?php

    // Вставка с помощью стандартного SQL запроса
    $sql     = "INSERT INTO `robots`(`name`, `year`) VALUES ('Astro Boy', 1952)";
    $success = $connection->execute($sql);

    // с помощью подготовленного запроса
    $sql     = "INSERT INTO `robots`(`name`, `year`) VALUES (?, ?)";
    $success = $connection->execute($sql, array('Astroy Boy', 1952));

    // Динамическое создание запроса с помощью метода класса
    $success = $connection->insert(
       "robots",
       array("Astro Boy", 1952),
       array("name", "year")
    );

    // Generating dynamically the necessary SQL (another syntax)
    $success = $connection->insertAsDict(
       "robots",
       array(
          "name" => "Astro Boy",
          "year" => 1952
       )
    );

    // Обновление с помощью стандартного SQL запроса
    $sql     = "UPDATE `robots` SET `name` = 'Astro boy' WHERE `id` = 101";
    $success = $connection->execute($sql);

    // с помощью подготовленного запроса
    $sql     = "UPDATE `robots` SET `name` = ? WHERE `id` = ?";
    $success = $connection->execute($sql, array('Astro Boy', 101));

    // Динамическое создание запроса с помощью метода класса
    $success = $connection->update(
       "robots",
       array("name"),
       array("New Astro Boy"),
       "id = 101" // Внимание! Значения не экранируются
    );

    // Динамическое создание запроса с помощью метода класса (другой синтаксис)
    $success = $connection->updateAsDict(
       "robots",
       array(
          "name" => "New Astro Boy"
       ),
       "id = 101" // Внимание! Значения не экранируются
    );

    // С экранированием условий
    $success = $connection->update(
       "robots",
       array("name"),
       array("New Astro Boy"),
       array(
          'conditions' => 'id = ?',
          'bind' => array(101),
          'bindTypes' => array(PDO::PARAM_INT) // Необязательный параметр
       )
    );
    $success = $connection->updateAsDict(
       "robots",
       array(
          "name" => "New Astro Boy"
       ),
       array(
          'conditions' => 'id = ?',
          'bind' => array(101),
          'bindTypes' => array(PDO::PARAM_INT) // Необязательный параметр
       )
    );

    // Удаление с помощью стандартного SQL запроса
    $sql     = "DELETE `robots` WHERE `id` = 101";
    $success = $connection->execute($sql);

    // с помощью подготовленного запроса
    $sql     = "DELETE `robots` WHERE `id` = ?";
    $success = $connection->execute($sql, array(101));

    // Динамическое создание запроса с помощью метода класса
    $success = $connection->delete("robots", "id = ?", array(101));

Транзакции и вложенные транзакции
---------------------------------
Работа с транзакциями поддерживается с помощью PDO.  Манипуляции с данными внутри транзакции часто увеличивает
скорость работы базы данных на большинстве систем.

.. code-block:: php

    <?php

    try {

        // Начало новой транзакции
        $connection->begin();

        // Выполнение нескольких команд SQL
        $connection->execute("DELETE `robots` WHERE `id` = 101");
        $connection->execute("DELETE `robots` WHERE `id` = 102");
        $connection->execute("DELETE `robots` WHERE `id` = 103");

        // Фиксируем изменения в транзакции, если все хорошо.
        $connection->commit();

    } catch (Exception $e) {
        // В случаи исключения откатываем все изменения
        $connection->rollback();
    }

В дополнение к стандартным транзакциям, Phalcon\\Db обеспечивает встроенную поддержку `вложенных транзакции`_
(если база данных поддерживает их). Когда вы вызываете метод begin() во второй раз – создается вложенная транзакция:

.. code-block:: php

    <?php

    try {

        // Начало новой транзакции
        $connection->begin();

        // Выполнение нескольких команд SQL
        $connection->execute("DELETE `robots` WHERE `id` = 101");

        try {

            // Начало вложенной транзакции
            $connection->begin();

            // Выполнение нескольких команд SQL во вложенной транзакции
            $connection->execute("DELETE `robots` WHERE `id` = 102");
            $connection->execute("DELETE `robots` WHERE `id` = 103");

            // Создаем точку сохранения
            $connection->commit();

        } catch (Exception $e) {
            // В случаи исключения откатываем все изменения
            $connection->rollback();
        }

        // Продолжаем Выполнение нескольких команд SQL
        $connection->execute("DELETE `robots` WHERE `id` = 104");

        // Фиксируем изменения в транзакции, если все хорошо.
        $connection->commit();

    } catch (Exception $e) {
        // В случаи исключения откатываем все изменения
        $connection->rollback();
    }

События базы данных
-------------------
:doc:`Phalcon\\Db <../api/Phalcon_Db>` способен передавать :doc:`EventsManager <events>`, если оно есть.
Некоторые события при возвращении булева значения ‘false’ могут остановить выполняемую операцию. Поддерживаются
следующие события:

+---------------------+-----------------------------------------------------------+-------------------------+
| Название            | Когда срабатывает                                         | Может остановить работу?|
+=====================+===========================================================+=========================+
| afterConnect        | После успешного подключения к БД                          | Нет                     |
+---------------------+-----------------------------------------------------------+-------------------------+
| beforeQuery         | Перед отправкой SQL в БД                                  | Да                      |
+---------------------+-----------------------------------------------------------+-------------------------+
| afterQuery          | После отправки запроса в БД                               | Нет                     |
+---------------------+-----------------------------------------------------------+-------------------------+
| beforeDisconnect    | Перед закрытием временного соединения с БД                | Нет                     |
+---------------------+-----------------------------------------------------------+-------------------------+
| beginTransaction    | Перед началом транзакции                                  | Нет                     |
+---------------------+-----------------------------------------------------------+-------------------------+
| rollbackTransaction | Перед откатом изменений произведенных в транзакции        | Нет                     |
+---------------------+-----------------------------------------------------------+-------------------------+
| commitTransaction   | Перед фиксацией транзакции                                | Нет                     |
+---------------------+-----------------------------------------------------------+-------------------------+

Привязать менеджер событий к соединению просто, :doc:`Phalcon\\Db <../api/Phalcon_Db>` будет вызывать событие с именем “db”:

.. code-block:: php

    <?php

    use Phalcon\Events\Manager as EventsManager;
    use Phalcon\Db\Adapter\Pdo\Mysql as Connection;

    $eventsManager = new EventsManager();

    // Прослушать все события базы данных
    $eventsManager->attach('db', $dbListener);

    $connection = new Connection(
        array(
            "host"     => "localhost",
            "username" => "root",
            "password" => "secret",
            "dbname"   => "invo"
        )
    );

    // Назначаем менеджер событий экземпляру адаптера БД
    $connection->setEventsManager($eventsManager);

Иметь возможность остановить выполнение SQL очень полезно, если вы хотите осуществить последнюю проверку SQL на наличие SQL инъекций:

.. code-block:: php

    <?php

    $eventsManager->attach('db:beforeQuery', function ($event, $connection) {

        // Проверка на наличие вредоносных ключевых слов в SQL
        if (preg_match('/DROP|ALTER/i', $connection->getSQLStatement())) {
            // DROP / ALTER операции не разрешено использовать в приложении,
            // это должно быть SQL инъекция!
            return false;
        }

        // Все хорошо
        return true;
    });

Профилирование запросов SQL
---------------------------
:doc:`Phalcon\\Db <../api/Phalcon_Db>` включает в себя компонент профилирования SQL запросов под
названием :doc:`Phalcon\\Db\\Profiler <../api/Phalcon_Db_Profiler>`, который используется для анализа
производительности запросов к базе данных для того, чтобы диагностировать проблему с производительностью
и обнаружить узкие места.

Профилировать базу данных легко с помощью :doc:`Phalcon\\Db\\Profiler <../api/Phalcon_Db_Profiler>`:

.. code-block:: php

    <?php

    use Phalcon\Events\Manager as EventsManager;
    use Phalcon\Db\Profiler as DbProfiler;

    $eventsManager = new EventsManager();

    $profiler = new DbProfiler();

    // Слушаем все события БД
    $eventsManager->attach('db', function ($event, $connection) use ($profiler) {
        if ($event->getType() == 'beforeQuery') {
            // Запуск профайлера с текущим соединением
            $profiler->startProfile($connection->getSQLStatement());
        }
        if ($event->getType() == 'afterQuery') {
            // Остановка текущего профайлера
            $profiler->stopProfile();
        }
    });

    // Назначаем менеджер событий соединению
    $connection->setEventsManager($eventsManager);

    $sql = "SELECT buyer_name, quantity, product_name "
         . "FROM buyers "
         . "LEFT JOIN products ON buyers.pid = products.id";

    // Выполняем SQLзапрос
    $connection->query($sql);

    // Получаем последний профиль в профайлере
    $profile = $profiler->getLastProfile();

    echo "SQL Statement: ", $profile->getSQLStatement(), "\n";
    echo "Start Time: ", $profile->getInitialTime(), "\n";
    echo "Final Time: ", $profile->getFinalTime(), "\n";
    echo "Total Elapsed Time: ", $profile->getTotalElapsedSeconds(), "\n";

Вы также можете создать свой собственный компонент профилирования на основе :doc:`Phalcon\\Db\\Profiler <../api/Phalcon_Db_Profiler>`
для записи статистики запросов к БД в режиме реального времени:

.. code-block:: php

    <?php

    use Phalcon\Events\Manager as EventsManager;
    use Phalcon\Db\Profiler as Profiler;
    use Phalcon\Db\Profiler\Item as Item;

    class DbProfiler extends Profiler
    {
        /**
         * Выполняется перед отправкой SQL запроса на сервер БД
         */
        public function beforeStartProfile(Item $profile)
        {
            echo $profile->getSQLStatement();
        }

        /**
         * Выполняется после отправки SQL запроса на сервер БД
         */
        public function afterEndProfile(Item $profile)
        {
            echo $profile->getTotalElapsedSeconds();
        }
    }

    // Создание менеджера событий
    $eventsManager = new EventsManager();

    // Создание слушателя
    $dbProfiler = new DbProfiler();

    // Прикрепляем слушателя ко всем событиям базы данных
    $eventsManager->attach('db', $dbProfiler);

Логирование SQL запросов
------------------------
Использование компонентов высокого уровня абстракции для доступа к базам данных, таких как
:doc:`Phalcon\\Db <../api/Phalcon_Db>`, усложняет понимание того, какие запросы отправляются в базу данных.
:doc:`Phalcon\\Logger <../api/Phalcon_Logger>` взаимодействует с :doc:`Phalcon\\Db <../api/Phalcon_Db>`,
обеспечивая возможность логирования в слое абстракции базы данных.

.. code-block:: php

    <?php

    use Phalcon\Logger;
    use Phalcon\Events\Manager as EventsManager;
    use Phalcon\Logger\Adapter\File as FileLogger;

    $eventsManager = new EventsManager();

    $logger = new FileLogger("app/logs/db.log");

    // Слушаем все события БД
    $eventsManager->attach('db', function ($event, $connection) use ($logger) {
        if ($event->getType() == 'beforeQuery') {
            $logger->log($connection->getSQLStatement(), Logger::INFO);
        }
    });

    // Назначаем менеджер событий соединению
    $connection->setEventsManager($eventsManager);

    // Выполняем несколько SQL запросов
    $connection->insert(
        "products",
        array("Hot pepper", 3.50),
        array("name", "price")
    );

Упомянутый выше файл *app/logs/db.log* будет содержать что-то похожее на это:

.. code-block:: php

    [Sun, 29 Apr 12 22:35:26 -0500][DEBUG][Resource Id #77] INSERT INTO products
    (name, price) VALUES ('Hot pepper', 3.50)


Реализация собственного логера
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Вы можете реализовать свой собственный класс логера запросов к базе данных, путем создания класса, который реализует
единственный метод, именуемый «log». Метод должен принимать строку в качестве первого аргумента. Затем Вы можете
передать ваш объект логера в  метод Phalcon\\Db::setLogger(), после чего любые выполняемые запросы SQL будут
вызывать этот метод для логирования результата запроса.

Описание Таблиц / Представлений
-------------------------------
:doc:`Phalcon\\Db <../api/Phalcon_Db>` также предоставляет методы для получения подробной информации о таблицах и представлениях:

.. code-block:: php

    <?php

    // Получаем таблицы из базы данных test_db
    $tables = $connection->listTables("test_db");

    // Есть ли таблица 'robots' в базе данных?
    $exists = $connection->tableExists("robots");

    // Получаем имена, типы данных и свойства полей таблицы 'robots'
    $fields = $connection->describeColumns("robots");
    foreach ($fields as $field) {
        echo "Column Type: ", $field["Type"];
    }

    // Получаем индексы таблицы 'robots'
    $indexes = $connection->describeIndexes("robots");
    foreach ($indexes as $index) {
        print_r($index->getColumns());
    }

    // Получаем внешние ключи на таблицу 'robots'
    $references = $connection->describeReferences("robots");
    foreach ($references as $reference) {
        // Выводим на экран ссылаемые столбцы
        print_r($reference->getReferencedColumns());
    }

Таблица описания  очень похожа на результат команды “DESCRIBE” в MySQL, она содержит следующую информацию:

+---------+----------------------------------------------------------+
| Индексы | Описание                                                 |
+=========+==========================================================+
| Field   | Имя поля                                                 |
+---------+----------------------------------------------------------+
| Type    | Тип столбца                                              |
+---------+----------------------------------------------------------+
| Key     | Является ли столбец частью первичного ключа или индексом?|
+---------+----------------------------------------------------------+
| Null    | Допускается ли значение NULL.                            |
+---------+----------------------------------------------------------+

Методы для получения сведений о представлениях также реализованы для всех поддерживаемых баз данных:

.. code-block:: php

    <?php

    // Получить все представления из базы данных ’test_db’
    $tables = $connection->listViews("test_db");

    // Есть ли представление ‘robots’ в базе данных?
    $exists = $connection->viewExists("robots");

Создание / Изменение / удаление таблиц
--------------------------------------
Различные системы баз данных (MySQL, PostgreSQL и др.) предоставляют возможность создавать, изменять
или удалять таблицы с использованием  таких команды как CREATE, ALTER или DROP. Синтаксис SQL отличается в
зависимости от того, какая база данных используется системой.
:doc:`Phalcon\\Db <../api/Phalcon_Db>` предлагает единый интерфейс для изменения таблиц, без необходимости
дифференцировать синтаксис SQL на основании системы хранения данных.

Создание таблиц
^^^^^^^^^^^^^^^
В следующем примере показано, как создать таблицу:

.. code-block:: php

    <?php

    use \Phalcon\Db\Column as Column;

    $connection->createTable(
        "robots",
        null,
        array(
           "columns" => array(
                new Column(
                    "id",
                    array(
                        "type"          => Column::TYPE_INTEGER,
                        "size"          => 10,
                        "notNull"       => true,
                        "autoIncrement" => true,
                        "primary"       => true,
                    )
                ),
                new Column(
                    "name",
                    array(
                        "type"    => Column::TYPE_VARCHAR,
                        "size"    => 70,
                        "notNull" => true,
                    )
                ),
                new Column(
                    "year",
                    array(
                        "type"    => Column::TYPE_INTEGER,
                        "size"    => 11,
                        "notNull" => true,
                    )
                )
            )
        )
    );

Phalcon\\Db::createTable() принимает ассоциативный массив описывающий таблицу. Столбцы определяются классом
:doc:`Phalcon\\Db\\Column <../api/Phalcon_Db_Column>`. В таблице ниже показаны варианты, доступные для определения
столбца:

+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| Опция           | Описани                                                                                                                                    | Необязательный? |
+=================+============================================================================================================================================+=================+
| "type"          | Тип столбца. Должен быть  константой быть Phalcon\\Db\\Column constant (см. ниже список)                                                   | Нет             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "primary"       | True, если столбец является частью первичного ключа таблицы                                                                                | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "size"          | Некоторые типы столбцов, такие как VARCHAR или INTEGER, могут иметь определенный размер                                                    | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "scale"         | DECIMAL или NUMBER столбцы могут  указывать точность (до какого десятичного знака требуется хранить числа).                                | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "unsigned"      | INTEGER столбцы могут быть знаковыми или беззнаковыми. Эта опция не распространяется на другие типы столбцов.                              | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "notNull"       | Может ли столбец хранить нулевые значения?                                                                                                 | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "autoIncrement" | С помощью этой опции, столбец заполняется автоматически с автоинкрементным целым. Только один столбец в таблице может иметь этот атрибут.  | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "bind"          | Одна из BIND_TYPE_* констант говорящая, как колонки должны быть привязаны перед сохранением.                                               | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "first"         | Колонки должны быть расположены на первой позиции в порядке столбцов                                                                       | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+
| "after"         | Колонка должна быть расположена после указанного столбца                                                                                   | Yes             |
+-----------------+--------------------------------------------------------------------------------------------------------------------------------------------+-----------------+

Phalcon\\Db поддерживает следующие типы столбцов базы данных:

* Phalcon\\Db\\Column::TYPE_INTEGER
* Phalcon\\Db\\Column::TYPE_DATE
* Phalcon\\Db\\Column::TYPE_VARCHAR
* Phalcon\\Db\\Column::TYPE_DECIMAL
* Phalcon\\Db\\Column::TYPE_DATETIME
* Phalcon\\Db\\Column::TYPE_CHAR
* Phalcon\\Db\\Column::TYPE_TEXT

Ассоциативный массив, переданный в  Phalcon\\Db::createTable() может иметь возможных ключей:

+--------------+----------------------------------------------------------------------------------------------------------------------------------------+------------------+
| Индекс       | Описание                                                                                                                               | Необязательный?  |
+==============+========================================================================================================================================+==================+
| "columns"    | Массив с набором столбцов таблицы определен с :doc:`Phalcon\\Db\\Column <../api/Phalcon_Db_Column>`                                    | Нет              |
+--------------+----------------------------------------------------------------------------------------------------------------------------------------+------------------+
| "indexes"    | Массив с набором индексов таблицы, определенные с :doc:`Phalcon\\Db\\Index <../api/Phalcon_Db_Index>`                                  | Да               |
+--------------+----------------------------------------------------------------------------------------------------------------------------------------+------------------+
| "references" | Массив с набором ссылок на таблицы (внешние ключи), определенный с :doc:`Phalcon\\Db\\Reference <../api/Phalcon_Db_Reference>`         | Да               |
+--------------+----------------------------------------------------------------------------------------------------------------------------------------+------------------+
| "options"    | Массив с набором опций для создания таблицы. Эти опции часто связаны с системой базы данных, в которых миграции был сгенерирован.      | Да               |
+--------------+----------------------------------------------------------------------------------------------------------------------------------------+------------------+

Изменение таблиц
^^^^^^^^^^^^^^^^
Если ваше приложение растет, вам, возможно, потребуется вносить изменения в  базу данных, как часть рефакторинга или
добавление нового функционала. Не все базы данных позволяют изменять существующие столбцы или добавить столбцы между
двумя существующими. :doc:`Phalcon\\Db <../api/Phalcon_Db>` ограничено  этими особенностями реализации.

.. code-block:: php

    <?php

    use Phalcon\Db\Column as Column;

    // Добавляем новый столбец
    $connection->addColumn(
        "robots",
        null,
        new Column(
            "robot_type",
            array(
                "type"    => Column::TYPE_VARCHAR,
                "size"    => 32,
                "notNull" => true,
                "after"   => "name"
            )
        )
    );

    // Изменение существующего столбца
    $connection->modifyColumn(
        "robots",
        null,
        new Column(
            "name",
            array(
                "type"    => Column::TYPE_VARCHAR,
                "size"    => 40,
                "notNull" => true
            )
        )
    );

    // Удаление столбца "name"
    $connection->dropColumn(
        "robots",
        null,
        "name"
    );

Удаление таблицы
^^^^^^^^^^^^^^^^
Пример удаления таблицы:

.. code-block:: php

    <?php

    // Удаление таблицы “robots” из активной базы данных
    $connection->dropTable("robots");

    // Удаление таблицы "robots" из базы данных "machines"
    $connection->dropTable("robots", "machines");

.. _PDO: http://www.php.net/manual/en/book.pdo.php
.. _`вложенных транзакции`: http://en.wikipedia.org/wiki/Nested_transaction
