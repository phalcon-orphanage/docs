---
layout: article
language: 'zh-cn'
version: '4.0'
upgrade: '#acl'
category: 'acl'
---
# Access Control Lists Component

* * *

## Objects as role name and component name

Phalcon allows developers to define their own role and component objects. These objects must implement the supplied interfaces:

* [Phalcon\Acl\RoleAware](api/Phalcon_Acl_RoleAware) for Role
* [Phalcon\Acl\ComponentAware](api/Phalcon_Acl_ComponentAware) for Component

### Role

We can implement the [Phalcon\Acl\RoleAware](api/Phalcon_Acl_RoleAware) in our custom class with its own logic. The example below shows a new role object called `ManagerRole`:

```php
<?php

use Phalcon\Acl\RoleAware;

// Create our class which will be used as roleName
class ManagerRole implements RoleAware
{
    protected $id;

    protected $roleName;

    public function __construct($id, $roleName)
    {
        $this->id       = $id;
        $this->roleName = $roleName;
    }

    public function getId()
    {
        return $this->id;
    }

    // Implemented function from RoleAware Interface
    public function getRoleName()
    {
        return $this->roleName;
    }
}
```

### Component

We can implement the [Phalcon\Acl\ComponentAware](api/Phalcon_Acl_ComponentAware) in our custom class with its own logic. The example below shows a new role object called `ReportsComponent`:

```php
<?php

use Phalcon\Acl\ComponentAware;

// Create our class which will be used as componentName
class ReportsComponent implements ComponentAware
{
    protected $id;

    protected $componentName;

    protected $userId;

    public function __construct($id, $componentName, $userId)
    {
        $this->id          = $id;
        $this->componentName = $componentName;
        $this->userId      = $userId;
    }

    public function getId()
    {
        return $this->id;
    }

    public function getUserId()
    {
        return $this->userId;
    }

    // Implemented function from ComponentAware Interface
    public function getComponentName()
    {
        return $this->componentName;
    }
}
```

### ACL

These objects can now be used in our ACL.

```php <?php

use ManagerRole; use Phalcon\Acl; use Phalcon\Acl\Adapter\Memory as AclList; use Phalcon\Acl\Role; use Phalcon\Acl\Component; use ReportsComponent;

$acl = new AclList();

/** * Add the roles */ $acl->addRole('manager');

/** * Add the Components */ $acl->addComponent('reports', ['list', 'add', 'view']);

/** * Now tie them all together with a custom function. The ManagerRole and * ModelSbject parameters are necessary for the custom function to work */ $acl->allow( 'manager', 'reports', 'list', function (ManagerRole $manager, ModelComponent $model) { return $manager->getId() === $model->getUserId(); } );

// Create the custom objects $levelOne = new ManagerRole(1, 'manager-1'); $levelTwo = new ManagerRole(2, 'manager'); $admin = new ManagerRole(3, 'manager');

// id - name - userId $reports = new ModelComponent(2, 'reports', 2);

// Check whether our user objects have access // Returns false $acl->isAllowed($levelOne, $reports, 'list');

// Returns true $acl->isAllowed($levelTwo, $reports, 'list');

// Returns false $acl->isAllowed($admin, $reports, 'list'); ````

The second call for `$levelTwo` evaluates `true` since the `getUserId()` returns `2` which in turn is evaluated in our custom function. Also note that in the custom function for `allow()` the objects are automatically bound, providing all the data necessary for the custom function to work. The custom function can accept any number of additional parameters. The order of the parameters defined in the `function()` constructor does not matter, because the objects will be automatically discovered and bound.