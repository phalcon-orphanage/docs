---
layout: default
language: 'uk-ua'
version: '4.0'
title: 'Продуктивність'
keywords: 'performance, profiling, xdebug, xhprof, yslow, bytecode, продуктивність'
---

# Продуктивність

* * *

![](/assets/images/document-status-stable-success.svg) ![](/assets/images/version-{{ pageVersion }}.svg)

## Огляд

Погано написана програма завжди матиме низьку продуктивність. Найпоширеніший спосіб для розробників підвищити продуктивність своїх продуктів:

> просто забезпечити вищу потужність обладнання для нього
{: .alert .alert-info }

Проблема наведеного вище підходу має два недоліка. На початку в більшості випадків власник понесе додаткові витрати. Друга проблема полягає в тому, що настане момент, коли не можна буде більше покращити обладнання і єдиною альтернативою залишиться використання балансерів, докера, групування серверів і тощо, що тільки примножить витрати.

Але залишиться проблема - *погано написана програма*

Щоб прискорити вашу програму, потрібно переконатися в тому, що вона написана найкращим чином для виконання поставлених завдань. Ніщо не може бути кращим добре продуманого дизайну. Після цього слід братись за інші аспекти: - апаратне забезпечення сервера - маршрутизація клієнтських підключень (місце розташування, браузери) - затримки мережі - обладнання бази даних

і багато іншого. У цій статті ми спробуємо розглянути деякі сценарії, які можуть забезпечити краще розуміння того, де ваш додаток є дуже повільним.

> **ПРИМІТКА** Це **рекомендації** і хороші практики. Ви ні в якому разі не зобов'язані дотримуватися цих порад, і аж ніяк їх список не є вичерпним. Ваші стратегії підвищення продуктивності базуються насамперед на потребах вашого продукту.
{: .alert .alert-danger }

## Сервер

[Профілювання](https://en.wikipedia.org/wiki/Profiling_(computer_programming)) - це форма динамічного аналізу програм, яка пропонує метрики, що відповідають вашому продукту. Профілювання показує справжню картину того, що насправді відбувається в будь-який час у програмі, і таким чином направляйте вас до областей, де потрібна ваша увага. Профілювання має бути безперервним у виробничій програмі.

Це також створює додаткові витрати, що слід врахувати. Найбільш детальне профілювання відбувається з кожним запитом, але все це залежатиме від вашого трафіку. Ми, звичайно, не хочемо збільшувати навантаження на сервер тільки тому, що ми профілюємо додаток. Типовий спосіб профілювання - це один запит на 100 або 1 на 1000. Через деякий час буде достатньо даних для того, щоб зробити висновки щодо того, де відбувається уповільнення, чому виникли піки тощо.

### XDebug

[XDebug](https://xdebug.org/docs) пропонує дуже зручний профайлер прямо з коробки. Вам потрібно лише встановити розширення та увімкнути профілювання у вашому `php.ini`:

```ini
xdebug.profiler_enable = On
```

Використання інструменту, наприклад [Webgrind](https://github.com/jokkedk/webgrind) дозволить вам підключитись до [XDebug](https://xdebug.org/docs) і отримати дуже цінну інформацію про те, що відбувається з вашим кодом. [Webgrind](https://github.com/jokkedk/webgrind) пропонує статистику, які методи повільніші за інші, та іншу статистику.

### Xhprof

[Xhprof](https://github.com/facebook/xhprof) -- інше розширення для PHP додатків. Щоб увімкнути його, вам потрібно додати наступний рядок на початок файлу bootstrap:

```php
<?php

xhprof_enable(XHPROF_FLAGS_CPU + XHPROF_FLAGS_MEMORY);
```

Потім в кінці цього ж файлу збережіть профільовані дані:

```php
<?php

$xhprof_data = xhprof_disable('/tmp');

$XHPROF_ROOT = '/var/www/xhprof/';
include_once $XHPROF_ROOT . '/xhprof_lib/utils/xhprof_lib.php';
include_once $XHPROF_ROOT . '/xhprof_lib/utils/xhprof_runs.php';

$xhprof_runs = new XHProfRuns_Default();
$run_id = $xhprof_runs->save_run($xhprof_data, 'xhprof_testing');

echo "https://localhost/xhprof/xhprof_html/index.php?run={$run_id}&source=xhprof_testing\n";
```

Xhprof пропонує вбудований HTML оглядач для аналізу профільованих даних:

![](/assets/images/content/performance-xhprof-2.jpg)

![](/assets/images/content/performance-xhprof-1.jpg)

Як зазначено вище, профілювання може збільшити навантаження на ваш сервер. У випадку використання [Xhprof](https://github.com/facebook/xhprof)ви можете встановити умову, що запуск профілювання буде здійснюватись лише після X запитів.

### SQL-інструкції

Майже всі RDBM пропонують інструменти для визначення повільних SQL-команд. Визначення та виправлення повільних запитів дуже важливо з точки зору продуктивності на стороні сервера. MariaDB / MySql / AuroraDb пропонують налаштування, що дозволяють вести журнал `slow-query`. Після цього база даних зберігає власні метрики, і коли запиту буде потрібно більше часу для завершення, запис про нього буде зроблено в `slow-query` журналі. Цей журнал може бути проаналізовано командою розробників, щоб зробити відповідні правки у коді.

Щоб увімкнути цю функцію, вам потрібно буде додати це до `my.cnf` (не забудьте перезапустити ваш сервер бази даних)

```ini
log-slow-queries = /var/log/slow-queries.log
long_query_time = 1.5
```

## Клієнт

Іншою зоною, що потребує уваги розробника є клієнт. Поліпшення завантаження активів, таких як зображення, таблиці стилів, файли javascript, може значно підвищити продуктивність та покращити користувацький досвід. Є ряд інструментів, які можуть допомогти з ідентифікацією вузьких місць на стороні клієнта:

### Браузери

Більшість сучасних браузерів мають інструменти для обліку часу завантаження сторінки. Вони називаються *веб-інспекторами* або *інструментами розробника*. Наприклад, при використанні будь-якого браузера на базі Chromium чи Brave, ви можете проінспектувати сторінку, а інструменти розробника покажуть купу всього, що завантажилось для поточної сторінки (файли), скільки часу пройшло і загальний час завантаження:

![](/assets/images/content/performance-chrome-1.jpg)

Потенційно легке рішення для підвищення продуктивності на стороні клієнта — встановити правильні заголовки ресурсів так, щоб їх термін використання вичерпався якомога пізніше у майбутньому на противагу повторному їх завантаження із сервера щоразу, як здійснюється запит. Крім того, [постачальники CDN](https://en.wikipedia.org/wiki/Content_delivery_network) можуть допомогти з постачанням ресурсів з дата-центрів, що розташовані ближче до клієнта, який здійснює запит.

### Yahoo! YSlow

[YSlow](http://yslow.org/) analyzes web pages and suggests ways to improve their performance based on a set of [rules for high performance web pages](https://developer.yahoo.com/performance/rules.html)

![](/assets/images/content/performance-yslow-1.jpg)

## PHP

PHP стає швидшим з кожною новою версією. Використання останньої версії покращує продуктивність ваших продуктів, а також Phalcon.

### Байт-код кеш

[OPcache](https://php.net/manual/en/book.opcache.php), як і більшість інших байт-код кешів, допомагає програмам зменшити накладні витрати на читання, маркування і аналіз вмісту PHP файлів у кожному запиті. Результати інтерпретації зберігаються в оперативній пам'яті між запитами до тих пір, поки PHP запускається як fcgi (fpm) або mod_php. OPcache включено до php починаючи з версії 5.5.0. Щоб перевірити чи його активовано, перевірте такий запис в php.ini:

```ini
opcache.enable = On
opcache.memory_consumption = 128    ;default
```

Разом з тим, кількість доступної пам'яті для кешування opcode має бути достатньою для зберігання всіх файлів вашого продукту. Значення за замовчуванням 128 МБ зазвичай достатньє для навіть великих кодових баз.

### Сервісний кеш

[APCu](https://php.net/manual/en/book.apcu.php) можна використовувати для кешування операцій, що потребують значних розрахунків, або ж для повільних джерел даних, таких як веб-сервіси з високою затримкою. Інше питання, як визначити чи потрібно кешувати результат, - для цього є практичне правило: якщо відповідні операції мають часто виконуватись, а їх результат ідентичний. Переконайтеся за допомогою профілювання (інспектування), що така оптимізація фактично покращила час виконання запиту.

```ini
apc.enabled = On
apc.shm_size = 32M  ;default
```

Як і з вищезгаданим opcache, переконайтеся, що кількість оперативної пам'яті достатня для вашого продукту. Альтернативами APCu можуть бути [Redis](https://redis.io/) або [Memcached](https://memcached.org/), однак, для них необхідно запустити додаткові процеси на вашому сервері або іншій машині.

## Повільні завдання

Виходячи з потреб вашого продукту, може бути час, коли необхідно буде виконувати окремі завдання протягом тривалого часу. Прикладами таких завдань можуть бути: обробка відео, оптимізація зображень, надсилання електронних листів, генерування PDF-документів тощо. Ці завдання повинні бути виконані за допомогою фонових завдань. Звичайний процес: - додаток ініціює завдання, надіславши повідомлення диспетчеру черги - користувач бачить повідомлення, що завдання заплановане до виконання - у фоновому режимі (або на іншому сервері) робочий скрипт періодично перевіряє чергу виконання - коли приходить повідомлення, робочий скрипт визначає тип повідомлення і викликає відповідний сервіс для виконання завдання - після завершення завдання, користувач отримує повідомлення про те, що його дані готові.

Це спрощене уявлення про те, як працює черга фонових процесів, але можна запропонувати і кращі ідеї про те, як мають бути виконані фонові завдання. Також є безліч сервісів черг, які можна використовувати за допомогою відповідних бібліотек PHP:

* [NATS](https://nats.io)
* [RabbitMQ](https://www.rabbitmq.com/)
* [Redis](https://redis.io/)
* [Resque](https://github.com/chrisboulton/php-resque)
* [SQS](https://aws.amazon.com/sqs/)
* [ZeroMQ](https://www.zeromq.org/)

## Швидкість сторінки

[mod_pagespeed](https://www.modpagespeed.com/) пришвидшує роботу вашого сайту і зменшує час завантаження сторінки. Цей модуль Apache HTTP-сервера з відкритим вихідним кодом (також доступний для nginx) автоматично застосовує кращі практики веб продуктивності до сторінок і пов'язаних з ними ресурсами (CSS, JavaScript, зображення), не вимагаючи від вас змінити існуючий контент або робочий процес.
